import {
  Circle,
  Polygon
} from "./chunk-SKB4T4QD.js";
import {
  Slice
} from "./chunk-MD6PYTY6.js";
import {
  ColorSet,
  DataItem,
  RadialLabel,
  RoundedRectangle,
  Series
} from "./chunk-M3WCBVCU.js";
import {
  Container,
  Graphics,
  Label,
  ListTemplate,
  RADIANS,
  __awaiter,
  cos,
  cubic,
  getArcBounds,
  mergeTags,
  out,
  p100,
  p50,
  percent,
  relativeToValue,
  round,
  setColor,
  sin
} from "./chunk-7PJVI6CE.js";
import {
  Template,
  Theme,
  each,
  isNumber,
  move,
  remove
} from "./chunk-DNCBPH6C.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      // window object or global
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c3 = me.c, d = me.d, a3 = me.a;
          b = b << 25 ^ b >>> 7 ^ c3;
          c3 = c3 - d | 0;
          d = d << 24 ^ d >>> 8 ^ a3;
          a3 = a3 - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c3;
          me.c = c3 = c3 - d | 0;
          me.d = d << 16 ^ c3 >>> 16 ^ a3;
          return me.a = a3 - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(global, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x3 = 0;
          while (n < significance) {
            n = (n + x3) * width;
            d *= width;
            x3 = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x3 >>>= 1;
          }
          return (n + x3) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count3) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count3--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out2;
          if (nodecrypto && (out2 = nodecrypto.randomBytes)) {
            out2 = out2(width);
          } else {
            out2 = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out2);
          }
          return tostring(out2);
        } catch (e) {
          var browser = global.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
        }
      }
      function tostring(a3) {
        return String.fromCharCode.apply(0, a3);
      }
      mixkey(math.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/HierarchyDefaultTheme.js
var HierarchyDefaultTheme = class extends Theme {
  setupDefaultRules() {
    super.setupDefaultRules();
    const ic = this._root.interfaceColors;
    const gridLayout = this._root.gridLayout;
    const r = this.rule.bind(this);
    r("Hierarchy").setAll({
      legendLabelText: "{category}",
      legendValueText: "{sum.formatNumber('#.#')}",
      width: p100,
      height: p100,
      colors: ColorSet.new(this._root, { step: 2 }),
      downDepth: 1,
      initialDepth: 5,
      singleBranchOnly: true,
      maskContent: true,
      animationEasing: out(cubic)
    });
    r("HierarchyNode").setAll({
      toggleKey: "disabled",
      setStateOnChildren: true,
      position: "absolute",
      isMeasured: false,
      cursorOverStyle: "pointer",
      tooltipText: "{category}: {sum}"
    });
    r("HierarchyNode", ["last"]).setAll({
      cursorOverStyle: "default"
    });
    {
      const rule = r("Label", ["hierarchy", "node"]);
      rule.setAll({
        centerX: p50,
        centerY: p50,
        position: "absolute",
        paddingBottom: 1,
        paddingTop: 1,
        paddingRight: 4,
        paddingLeft: 4,
        text: "{category}",
        populateText: true,
        oversizedBehavior: "fit",
        minScale: 0.3
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
    {
      const rule = r("HierarchyLink");
      rule.setAll({
        isMeasured: false,
        position: "absolute",
        strokeWidth: 1,
        strokeOpacity: 1,
        strength: 0.9,
        distance: 1.1
      });
      setColor(rule, "stroke", ic, "grid");
    }
    r("Circle", ["linkedhierarchy", "shape"]).setAll({
      position: "absolute",
      fillOpacity: 1,
      strokeOpacity: 0,
      radius: 15,
      tooltipY: 0
    });
    r("Circle", ["linkedhierarchy", "shape", "outer"]).setAll({
      position: "absolute",
      opacity: 1,
      fillOpacity: 0,
      strokeDasharray: 0,
      strokeOpacity: 1,
      radius: 15,
      scale: 1.1,
      interactive: false
    });
    r("Circle", ["linkedhierarchy", "shape", "outer"]).states.create("disabled", { opacity: 1, scale: 1.1, strokeDasharray: 2 });
    r("Circle", ["linkedhierarchy", "shape", "outer"]).states.create("hoverDisabled", { scale: 1.2, opacity: 1, strokeDasharray: 2 });
    r("Circle", ["linkedhierarchy", "shape", "outer"]).states.create("hover", { scale: 1.05, strokeDasharray: 0 });
    r("Circle", ["linkedhierarchy", "shape", "outer"]).states.create("hidden", { opacity: 0, strokeDasharray: 0 });
    r("BreadcrumbBar").setAll({
      paddingLeft: 8,
      layout: gridLayout
    });
    {
      const rule = r("Label", ["breadcrumb"]);
      rule.setAll({
        paddingRight: 4,
        paddingLeft: 4,
        cursorOverStyle: "pointer",
        populateText: true,
        text: "{category}:"
      });
      setColor(rule, "fill", ic, "primaryButton");
    }
    {
      const rule = r("Label", ["breadcrumb"]).states.create("hover", {});
      setColor(rule, "fill", ic, "primaryButtonHover");
    }
    {
      const rule = r("Label", ["breadcrumb"]).states.create("down", { stateAnimationDuration: 0 });
      setColor(rule, "fill", ic, "primaryButtonDown");
    }
    {
      const rule = r("Label", ["breadcrumb", "last"]);
      rule.setAll({
        populateText: true,
        text: "{category}",
        fontWeight: "bold",
        cursorOverStyle: "default"
      });
      setColor(rule, "fill", ic, "primaryButton");
    }
    {
      const rule = r("RoundedRectangle", ["breadcrumb", "label", "background"]);
      rule.setAll({
        fillOpacity: 0
      });
      setColor(rule, "fill", ic, "background");
    }
    r("Partition").setAll({
      downDepth: 1,
      upDepth: 0,
      initialDepth: 5
    });
    r("HierarchyNode", ["partition"]).setAll({
      setStateOnChildren: false
    });
    r("HierarchyNode", ["partition"]).states.create("hidden", {
      opacity: 1,
      visible: true
    });
    {
      const rule = r("Label", ["partition", "node"]);
      rule.setAll({
        x: p50,
        y: p50,
        centerY: p50,
        centerX: p50,
        paddingBottom: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        rotation: 90,
        populateText: true,
        text: "{category}",
        oversizedBehavior: "fit",
        minScale: 0.4
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
    r("Label", ["horizontal", "partition", "node"]).setAll({
      rotation: 0
    });
    {
      const rule = r("RoundedRectangle", ["partition", "node", "shape"]);
      rule.setAll({
        strokeOpacity: 1,
        strokeWidth: 1,
        cornerRadiusBR: 0,
        cornerRadiusTR: 0,
        cornerRadiusBL: 0,
        cornerRadiusTL: 0
      });
      setColor(rule, "stroke", ic, "background");
    }
    r("RoundedRectangle", ["partition", "node", "shape", "last"]).setAll({
      fillOpacity: 0.75
    });
    r("Sunburst").setAll({
      singleBranchOnly: true
    });
    r("HierarchyNode", ["sunburst"]).setAll({
      setStateOnChildren: false
    });
    r("HierarchyNode", ["sunburst"]).states.create("hidden", {
      opacity: 0,
      visible: false
    });
    {
      const rule = r("Slice", ["sunburst", "node", "shape"]);
      rule.setAll({
        strokeOpacity: 1,
        strokeWidth: 1,
        cornerRadius: 0
      });
      setColor(rule, "stroke", ic, "background");
    }
    r("Slice", ["sunburst", "node", "shape", "last"]).setAll({
      fillOpacity: 0.75
    });
    {
      const rule = r("RadialLabel", ["sunburst", "node"]);
      rule.setAll({
        x: 0,
        y: 0,
        textType: "radial",
        paddingBottom: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        centerX: p50,
        populateText: true,
        text: "{category}",
        oversizedBehavior: "fit",
        minScale: 0.4,
        baseRadius: p50,
        rotation: 0
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
    r("ForceDirected").setAll({
      minRadius: percent(1),
      maxRadius: percent(8),
      initialFrames: 500,
      centerStrength: 0.8,
      manyBodyStrength: -14,
      velocityDecay: 0.5,
      linkWithStrength: 0.5,
      showOnFrame: 10,
      singleBranchOnly: false,
      upDepth: Infinity,
      downDepth: 1,
      initialDepth: 5,
      topDepth: 0
    });
    r("Tree").setAll({
      orientation: "vertical",
      paddingLeft: 20,
      paddingRight: 20,
      paddingTop: 20,
      paddingBottom: 20,
      singleBranchOnly: false,
      upDepth: Infinity,
      downDepth: 1,
      initialDepth: 5,
      topDepth: 0
    });
    r("Pack").setAll({
      paddingLeft: 20,
      paddingTop: 20,
      paddingBottom: 20,
      paddingRight: 20,
      nodePadding: 0
    });
    {
      const rule = r("Label", ["pack", "node"]);
      rule.setAll({
        centerY: p50,
        centerX: p50,
        paddingBottom: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        populateText: true,
        text: "{category}",
        oversizedBehavior: "fit",
        minScale: 0.4
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
    {
      const rule = r("Circle", ["pack", "node", "shape"]);
      rule.setAll({
        strokeOpacity: 0.5,
        fillOpacity: 0.8,
        strokeWidth: 1
      });
      setColor(rule, "stroke", ic, "background");
    }
    r("LinkedHierarchyNode").setAll({
      draggable: true
    });
    r("LinkedHierarchyNode").states.create("hidden", { scale: 0, opacity: 0, visible: false });
    r("Treemap").setAll({
      upDepth: 0,
      layoutAlgorithm: "squarify"
    });
    {
      const rule = r("Label", ["treemap", "node"]);
      rule.setAll({
        x: p50,
        y: p50,
        centerY: p50,
        centerX: p50,
        paddingBottom: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        populateText: true,
        text: "{category}",
        oversizedBehavior: "fit",
        minScale: 0.4
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
    r("HierarchyNode", ["treemap", "node"]).setAll({
      tooltipY: percent(40),
      isMeasured: false,
      position: "absolute"
    });
    {
      const rule = r("RoundedRectangle", ["treemap", "node", "shape"]);
      rule.setAll({
        strokeOpacity: 1,
        strokeWidth: 1,
        cornerRadiusBR: 0,
        cornerRadiusTR: 0,
        cornerRadiusBL: 0,
        cornerRadiusTL: 0,
        fillOpacity: 1
      });
      setColor(rule, "stroke", ic, "background");
    }
    {
      r("VoronoiTreemap").setAll({
        type: "polygon",
        minWeightRatio: 5e-3,
        convergenceRatio: 5e-3,
        maxIterationCount: 100,
        singleBranchOnly: true
      });
    }
    {
      const rule = r("Graphics", ["voronoitreemap", "node", "shape"]);
      rule.setAll({
        strokeOpacity: 1,
        strokeWidth: 1,
        fillOpacity: 1
      });
      setColor(rule, "stroke", ic, "background");
    }
    {
      r("Polygon", ["hierarchy", "node", "shape", "depth1"]).setAll({
        strokeWidth: 3
      });
    }
    {
      const rule = r("Label", ["voronoitreemap"]);
      rule.setAll({
        centerY: p50,
        centerX: p50,
        paddingBottom: 1,
        paddingTop: 1,
        paddingLeft: 1,
        paddingRight: 1,
        populateText: true,
        text: "{category}",
        oversizedBehavior: "fit",
        minScale: 0.4,
        layer: 30
      });
      setColor(rule, "fill", ic, "alternativeText");
    }
  }
};

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/BreadcrumbBar.js
var BreadcrumbBar = class extends Container {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "labels", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Label._new(this._root, {
        themeTags: mergeTags(this.labels.template.get("themeTags", []), ["label"]),
        background: RoundedRectangle.new(this._root, {
          themeTags: ["background"]
        })
      }, [this.labels.template]))
    });
    Object.defineProperty(this, "_disposer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  makeLabel(dataItem) {
    const label = this.labels.make();
    label._setDataItem(dataItem);
    label.states.create("hover", {});
    label.states.create("down", {});
    label.events.on("click", () => {
      const series = this.get("series");
      if (series) {
        series.selectDataItem(dataItem);
      }
    });
    this.labels.push(label);
    return label;
  }
  _afterNew() {
    this._defaultThemes.push(HierarchyDefaultTheme.new(this._root));
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["breadcrumb"]);
    super._afterNew();
  }
  _changed() {
    super._changed();
    if (this.isDirty("series")) {
      const series = this.get("series");
      const previous = this._prevSettings.series;
      if (series != previous) {
        this._disposer = series.events.on("dataitemselected", (event) => {
          this._handleDataItem(event.dataItem);
        });
      } else if (previous) {
        if (this._disposer) {
          this._disposer.dispose();
        }
      }
      this._handleDataItem(series.get("selectedDataItem"));
    }
  }
  _handleDataItem(dataItem) {
    this.set("minHeight", this.height());
    this.children.clear();
    this.labels.clear();
    if (dataItem) {
      let parent = dataItem;
      while (parent) {
        let label = this.makeLabel(parent);
        if (parent == dataItem) {
          label.addTag("last");
        }
        this.children.moveValue(label, 0);
        parent = parent.get("parent");
      }
    }
  }
};
Object.defineProperty(BreadcrumbBar, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "BreadcrumbBar"
});
Object.defineProperty(BreadcrumbBar, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Container.classNames.concat([BreadcrumbBar.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/HierarchyNode.js
var HierarchyNode = class extends Container {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "series", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_clickDisposer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNew();
    this.states.create("disabled", {});
    this.states.create("hover", {});
    this.states.create("hoverDisabled", {});
    this.on("disabled", () => {
      const dataItem = this.dataItem;
      if (!dataItem.get("children")) {
        this.set("disabled", true);
        return;
      }
      const disabled = this.get("disabled");
      const series = this.series;
      if (dataItem && series) {
        if (dataItem.get("disabled") != disabled) {
          if (disabled) {
            series.disableDataItem(dataItem);
          } else {
            series.enableDataItem(dataItem, series.get("downDepth", 1), 0);
          }
        }
      }
    });
  }
  _changed() {
    super._changed();
    if (this.isDirty("toggleKey")) {
      const toggleKey = this.get("toggleKey");
      if (toggleKey == "disabled") {
        this._clickDisposer = this.events.on("click", () => {
          if (!this._isDragging) {
            let series = this.series;
            if (series) {
              series.selectDataItem(this.dataItem);
            }
          }
        });
      } else {
        if (this._clickDisposer) {
          this._clickDisposer.dispose();
        }
      }
    }
  }
};
Object.defineProperty(HierarchyNode, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "HierarchyNode"
});
Object.defineProperty(HierarchyNode, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Container.classNames.concat([HierarchyNode.className])
});

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum2 = +value(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum2 += children[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b) {
  if (a3 === b)
    return a3;
  var aNodes = a3.ancestors(), bNodes = b.ancestors(), c3 = null;
  a3 = aNodes.pop();
  b = bNodes.pop();
  while (a3 === b) {
    c3 = a3;
    a3 = aNodes.pop();
    b = bNodes.pop();
  }
  return c3;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node(data), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}
function shuffle(array2, random) {
  let m3 = array2.length, t, i;
  while (m3) {
    i = random() * m3-- | 0;
    t = array2[m3];
    array2[m3] = array2[i];
    array2[i] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }
  return e;
}
function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B))
    return [p];
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a3, b) {
  var dr = a3.r - b.r, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b) {
  var dr = a3.r - b.r + Math.max(a3.r, b.r, 1) * 1e-9, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a3, B[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    r: a3.r
  };
}
function encloseBasis2(a3, b) {
  var x1 = a3.x, y1 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x1, y21 = y22 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x22 + x21 / l * r21) / 2,
    y: (y1 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b, c3) {
  var x1 = a3.x, y1 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c3.x, y3 = c3.y, r3 = c3.r, a22 = x1 - x22, a32 = x1 - x3, b2 = y1 - y22, b3 = y1 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y1, yb = (a22 * c32 - a32 * c22) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a3, c3) {
  var dx = b.x - a3.x, x3, a22, dy = b.y - a3.y, y3, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a3.r + c3.r, a22 *= a22;
    b2 = b.r + c3.r, b2 *= b2;
    if (a22 > b2) {
      x3 = (d2 + b2 - a22) / (2 * d2);
      y3 = Math.sqrt(Math.max(0, b2 / d2 - x3 * x3));
      c3.x = b.x - x3 * dx - y3 * dy;
      c3.y = b.y - x3 * dy + y3 * dx;
    } else {
      x3 = (d2 + a22 - b2) / (2 * d2);
      y3 = Math.sqrt(Math.max(0, a22 / d2 - x3 * x3));
      c3.x = a3.x + x3 * dx - y3 * dy;
      c3.y = a3.y + x3 * dy + y3 * dx;
    }
  } else {
    c3.x = a3.x + c3.r;
    c3.y = a3.y;
  }
}
function intersects(a3, b) {
  var dr = a3.r + b.r - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a3 = node._, b = node.next._, ab = a3.r + b.r, dx = (a3.x * b.r + b.x * a3.r) / ab, dy = (a3.y * b.r + b.y * a3.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random) {
  if (!(n = (circles = array_default(circles)).length))
    return 0;
  var a3, b, c3, n, aa, ca, i, j, k, sj, sk;
  a3 = circles[0], a3.x = 0, a3.y = 0;
  if (!(n > 1))
    return a3.r;
  b = circles[1], a3.x = -b.r, b.x = a3.r, b.y = 0;
  if (!(n > 2))
    return a3.r + b.r;
  place(b, a3, c3 = circles[2]);
  a3 = new Node2(a3), b = new Node2(b), c3 = new Node2(c3);
  a3.next = c3.previous = b;
  b.next = a3.previous = c3;
  c3.next = b.previous = a3;
  pack:
    for (i = 3; i < n; ++i) {
      place(a3._, b._, c3 = circles[i]), c3 = new Node2(c3);
      j = b.next, k = a3.previous, sj = b._.r, sk = a3._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c3._)) {
            b = j, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c3._)) {
            a3 = k, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c3.previous = a3, c3.next = b, a3.next = b.previous = b = c3;
      aa = score(a3);
      while ((c3 = c3.next) !== b) {
        if ((ca = score(c3)) < aa) {
          a3 = c3, aa = ca;
        }
      }
      b = a3.next;
    }
  a3 = [b._], c3 = b;
  while ((c3 = c3.next) !== b)
    a3.push(c3._);
  c3 = packEncloseRandom(a3, random);
  for (i = 0; i < n; ++i)
    a3 = circles[i], a3.x -= c3.x, a3.y -= c3.y;
  return c3.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root) {
    const random = lcg_default();
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack.radius = function(x3) {
    return arguments.length ? (radius = optional(x3), pack) : radius;
  };
  pack.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], pack) : [dx, dy];
  };
  pack.padding = function(x3) {
    return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default(+x3), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k, random) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding(node) * k || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packSiblingsRandom(children, random);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round2 = false;
  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round2)
      root.eachBefore(round_default);
    return root;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition.round = function(x3) {
    return arguments.length ? (round2 = !!x3, partition) : round2;
  };
  partition.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], partition) : [dx, dy];
  };
  partition.padding = function(x3) {
    return arguments.length ? (padding = +x3, partition) : padding;
  };
  return partition;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation(a3, b) {
  return a3.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root.eachBefore(sizeNode);
    else {
      var left = root, right = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x3) {
    return arguments.length ? (separation = x3, tree) : separation;
  };
  tree.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else
      slice_default(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function(x3) {
    return custom((x3 = +x3) > 1 ? x3 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root.eachBefore(round_default);
    return root;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x3) {
    return arguments.length ? (round2 = !!x3, treemap) : round2;
  };
  treemap.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x3) {
    return arguments.length ? (tile = required(x3), treemap) : tile;
  };
  treemap.padding = function(x3) {
    return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x3) {
    return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default(+x3), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x3) {
    return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x3) {
    return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default(+x3), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x3) {
    return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default(+x3), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x3) {
    return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default(+x3), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x3) {
    return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default(+x3), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition(0, n, parent.value, x0, y0, x1, y1);
  function partition(i2, j, value, x02, y02, x12, y12) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x02, node.y0 = y02;
      node.x1 = x12, node.y1 = y12;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget)
        k = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
    if (x12 - x02 > y12 - y02) {
      var xk = value ? (x02 * valueRight + x12 * valueLeft) / value : x12;
      partition(i2, k, valueLeft, x02, y02, xk, y12);
      partition(k, j, valueRight, xk, y02, x12, y12);
    } else {
      var yk = value ? (y02 * valueRight + y12 * valueLeft) / value : y12;
      partition(i2, k, valueLeft, x02, y02, x12, yk);
      partition(k, j, valueRight, x02, yk, x12, y12);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x0, y0, x1, y1);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom2(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value = parent.value;
      while (++j < m3) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
        else
          slice_default(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x3) {
    return custom2((x3 = +x3) > 1 ? x3 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Hierarchy.js
var Hierarchy = class extends Series {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "nodesContainer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.children.push(Container.new(this._root, { isMeasured: false }))
    });
    Object.defineProperty(this, "_rootNode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_treeData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "hierarchy"
    });
    Object.defineProperty(this, "nodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => HierarchyNode.new(this._root, {
        themeTags: mergeTags(this.nodes.template.get("themeTags", []), [this._tag, "hierarchy", "node"])
      }, this.nodes.template))
    });
    Object.defineProperty(this, "labels", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Label.new(this._root, {
        themeTags: mergeTags(this.labels.template.get("themeTags", []), [this._tag])
      }, this.labels.template))
    });
    Object.defineProperty(this, "_currentDownDepth", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const childData = dataItem.get("childData");
    const node = this.nodes.make();
    node.series = this;
    node._setDataItem(dataItem);
    this.nodes.push(node);
    dataItem.setRaw("node", node);
    const label = this.labels.make();
    label._setDataItem(dataItem);
    dataItem.setRaw("label", label);
    this.labels.push(label);
    if (!childData || childData.length == 0) {
      node.addTag("last");
    }
    const depth = dataItem.get("depth");
    node.addTag("depth" + depth);
    this.nodesContainer.children.push(node);
    node.children.push(label);
    return node;
  }
  _afterNew() {
    this._defaultThemes.push(HierarchyDefaultTheme.new(this._root));
    this.fields.push("category", "childData", "disabled", "fill");
    this.children.push(this.bulletsContainer);
    super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this._valuesDirty) {
      this._treeData = {};
      const first = this.dataItems[0];
      if (first) {
        this._makeHierarchyData(this._treeData, first);
        this._index = 0;
        this._rootNode = hierarchy(this._treeData);
        if (this._rootNode) {
          this._rootNode.sum((d) => {
            return d.value;
          });
          const sort2 = this.get("sort");
          if (sort2 == "descending") {
            this._rootNode.sort((a3, b) => b.value - a3.value);
          } else if (sort2 == "ascending") {
            this._rootNode.sort((a3, b) => a3.value - b.value);
          }
          this.setPrivateRaw("valueLow", Infinity);
          this.setPrivateRaw("valueHigh", -Infinity);
          this.setPrivateRaw("maxDepth", 0);
          this._updateValues(this._rootNode);
        }
      }
    }
    if (this._valuesDirty || this._sizeDirty) {
      this._updateVisuals();
    }
    if (this._sizeDirty) {
      const dataItem = this.get("selectedDataItem");
      if (dataItem) {
        this._zoom(dataItem);
      }
    }
  }
  _changed() {
    super._changed();
    if (this.isDirty("selectedDataItem")) {
      this._selectDataItem(this.get("selectedDataItem"));
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      this._updateNodes(this._rootNode);
    }
  }
  _updateNodes(hierarchyNode) {
    const dataItem = hierarchyNode.data.dataItem;
    if (dataItem) {
      this._updateNode(dataItem);
      if (this.bullets.length > 0 && !dataItem.bullets) {
        this._makeBullets(dataItem);
      }
      const hierarchyChildren = hierarchyNode.children;
      if (hierarchyChildren) {
        each(hierarchyChildren, (hierarchyChild) => {
          this._updateNodes(hierarchyChild);
        });
      }
    }
  }
  _updateNode(_dataItem) {
  }
  /**
   * Looks up and returns a data item by its ID.
   *
   * @param   id  ID
   * @return      Data item
   */
  getDataItemById(id) {
    return this._getDataItemById(this.dataItems, id);
  }
  _getDataItemById(dataItems, id) {
    let di;
    each(dataItems, (dataItem) => {
      if (dataItem.get("id") == id) {
        di = dataItem;
      }
      const children = dataItem.get("children");
      if (children) {
        let childDataItem = this._getDataItemById(children, id);
        if (childDataItem) {
          di = childDataItem;
        }
      }
    });
    return di;
  }
  _handleBullets(dataItems) {
    each(dataItems, (dataItem) => {
      const bullets = dataItem.bullets;
      if (bullets) {
        each(bullets, (bullet) => {
          bullet.dispose();
        });
        dataItem.bullets = void 0;
      }
      const children = dataItem.get("children");
      if (children) {
        this._handleBullets(children);
      }
    });
    this._updateVisuals();
  }
  _onDataClear() {
    super._onDataClear();
    const colors = this.get("colors");
    if (colors) {
      colors.reset();
    }
  }
  processDataItem(dataItem) {
    super.processDataItem(dataItem);
    const childData = dataItem.get("childData");
    const colors = this.get("colors");
    const topDepth = this.get("topDepth", 0);
    if (!dataItem.get("parent")) {
      dataItem.setRaw("depth", 0);
      if (colors && topDepth == 0 && dataItem.get("fill") == null) {
        dataItem.setRaw("fill", colors.next());
      }
    }
    let depth = dataItem.get("depth");
    const initialDepth = this.get("initialDepth", 1);
    this.makeNode(dataItem);
    this._processDataItem(dataItem);
    if (childData) {
      const children2 = [];
      dataItem.setRaw("children", children2);
      each(childData, (child) => {
        const childDataItem = new DataItem(this, child, this._makeDataItem(child));
        children2.push(childDataItem);
        childDataItem.setRaw("parent", dataItem);
        childDataItem.setRaw("depth", depth + 1);
        if (this.dataItems.length == 1 && depth == 0) {
          if (colors && childDataItem.get("fill") == null) {
            childDataItem.setRaw("fill", colors.next());
          }
        } else {
          if (childDataItem.get("fill") == null) {
            childDataItem.setRaw("fill", dataItem.get("fill"));
          }
        }
        this.processDataItem(childDataItem);
      });
    }
    const children = dataItem.get("children");
    if (!children || children.length == 0) {
      const node = dataItem.get("node");
      node.setAll({ toggleKey: void 0 });
    }
    if (dataItem.get("disabled") == null) {
      if (depth >= topDepth + initialDepth) {
        this.disableDataItem(dataItem, 0);
      }
    }
  }
  /**
   * Adds children data to the target data item.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/hierarchy/hierarchy-api/#Dynamically_adding_child_nodes} for more info
   * @since 5.4.5
   */
  addChildData(dataItem, data) {
    const dataContext = dataItem.dataContext;
    const childDataField = this.get("childDataField");
    let childData = dataContext[childDataField];
    if (!childData) {
      childData = data;
      dataContext[childDataField] = childData;
    } else {
      childData.push(...data);
    }
    let children = dataItem.get("children");
    if (!children) {
      children = [];
      dataItem.set("children", children);
    }
    let depth = dataItem.get("depth");
    each(childData, (child) => {
      const childDataItem = new DataItem(this, child, this._makeDataItem(child));
      children.push(childDataItem);
      childDataItem.setRaw("parent", dataItem);
      childDataItem.setRaw("depth", depth + 1);
      if (childDataItem.get("fill") == null) {
        childDataItem.setRaw("fill", dataItem.get("fill"));
      }
      this.processDataItem(childDataItem);
    });
  }
  _processDataItem(_dataItem) {
  }
  _updateValues(d3HierarchyNode) {
    const dataItem = d3HierarchyNode.data.dataItem;
    if (d3HierarchyNode.depth > this.getPrivate("maxDepth")) {
      this.setPrivateRaw("maxDepth", d3HierarchyNode.depth);
    }
    if (dataItem) {
      dataItem.setRaw("d3HierarchyNode", d3HierarchyNode);
      d3HierarchyNode.index = this._index;
      this._index++;
      dataItem.get("node").set("disabled", dataItem.get("disabled"));
      let dataValue = d3HierarchyNode.data.value;
      let value = d3HierarchyNode.value;
      if (dataValue != null) {
        value = dataValue;
        d3HierarchyNode["value"] = value;
      }
      if (isNumber(value)) {
        dataItem.setRaw("sum", value);
        dataItem.setRaw("valuePercentTotal", value / this.dataItems[0].get("sum") * 100);
        let valuePercent = 100;
        const parent = dataItem.get("parent");
        if (parent) {
          valuePercent = value / parent.get("sum") * 100;
        }
        dataItem.get("label").text.markDirtyText();
        dataItem.setRaw("valuePercent", valuePercent);
        if (this.getPrivate("valueLow") > value) {
          this.setPrivateRaw("valueLow", value);
        }
        if (this.getPrivate("valueHigh") < value) {
          this.setPrivateRaw("valueHigh", value);
        }
      }
      this.updateLegendValue(dataItem);
    }
    const hierarchyChildren = d3HierarchyNode.children;
    if (hierarchyChildren) {
      each(hierarchyChildren, (d3HierarchyChild) => {
        this._updateValues(d3HierarchyChild);
      });
    }
  }
  _makeHierarchyData(data, dataItem) {
    data.dataItem = dataItem;
    const children = dataItem.get("children");
    if (children) {
      const childrenDataArray = [];
      data.children = childrenDataArray;
      each(children, (childDataItem) => {
        const childData = {};
        childrenDataArray.push(childData);
        this._makeHierarchyData(childData, childDataItem);
      });
      const value = dataItem.get("valueWorking");
      if (isNumber(value)) {
        data.value = value;
      }
    } else {
      const value = dataItem.get("valueWorking");
      if (isNumber(value)) {
        data.value = value;
      }
    }
  }
  /**
   * @ignore
   */
  disposeDataItem(dataItem) {
    super.disposeDataItem(dataItem);
    const node = dataItem.get("node");
    if (node) {
      this.nodes.removeValue(node);
      node.dispose();
    }
    const label = dataItem.get("label");
    if (label) {
      this.labels.removeValue(label);
      label.dispose();
    }
    const children = dataItem.get("children");
    if (children) {
      each(children, (child) => {
        this.disposeDataItem(child);
      });
    }
  }
  /**
   * Hides hierarchy's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(dataItem, duration) {
    const _super = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const promises = [_super.hideDataItem.call(this, dataItem, duration)];
      const hiddenState = this.states.create("hidden", {});
      if (!isNumber(duration)) {
        const stateAnimationDuration = "stateAnimationDuration";
        duration = hiddenState.get(stateAnimationDuration, this.get(stateAnimationDuration, 0));
      }
      const stateAnimationEasing = "stateAnimationEasing";
      const easing = hiddenState.get(stateAnimationEasing, this.get(stateAnimationEasing));
      const children = dataItem.get("children");
      if ((!children || children.length == 0) && isNumber(dataItem.get("value"))) {
        promises.push(dataItem.animate({ key: "valueWorking", to: 0, duration, easing }).waitForStop());
      }
      const node = dataItem.get("node");
      node.hide();
      node.hideTooltip();
      if (children) {
        each(children, (childDataItem) => {
          promises.push(this.hideDataItem(childDataItem));
        });
      }
      yield Promise.all(promises);
    });
  }
  /**
   * Shows hierarchy's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(dataItem, duration) {
    const _super = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const promises = [_super.showDataItem.call(this, dataItem, duration)];
      if (!isNumber(duration)) {
        duration = this.get("stateAnimationDuration", 0);
      }
      const easing = this.get("stateAnimationEasing");
      const children = dataItem.get("children");
      if ((!children || children.length == 0) && isNumber(dataItem.get("value"))) {
        promises.push(dataItem.animate({ key: "valueWorking", to: dataItem.get("value"), duration, easing }).waitForStop());
      }
      const node = dataItem.get("node");
      node.show();
      if (children) {
        each(children, (childDataItem) => {
          promises.push(this.showDataItem(childDataItem));
        });
      }
      yield Promise.all(promises);
    });
  }
  /**
   * Enables a disabled data item.
   *
   * @param  dataItem  Target data item
   * @param  duration  Animation duration in milliseconds
   */
  enableDataItem(dataItem, maxDepth, depth, duration) {
    if (depth == null) {
      depth = 0;
    }
    if (maxDepth == null) {
      maxDepth = 1;
    }
    dataItem.set("disabled", false);
    dataItem.get("node").set("disabled", false);
    if (!dataItem.isHidden()) {
      dataItem.get("node").show(duration);
    }
    const topDepth = this.get("topDepth", 0);
    if (dataItem.get("depth") < topDepth) {
      dataItem.get("node").hide(0);
    }
    if (depth == 0) {
      const upDepth = this.get("upDepth", Infinity);
      let parent = dataItem;
      let count3 = 0;
      while (parent !== void 0) {
        if (count3 > upDepth) {
          parent.get("node").hide();
        }
        parent = parent.get("parent");
        count3++;
      }
    }
    let children = dataItem.get("children");
    if (children) {
      if (depth < maxDepth - 1) {
        each(children, (child) => {
          const disabledField = this.get("disabledField");
          if (disabledField) {
            const dataContext = child.dataContext;
            if (dataContext[disabledField] != true) {
              this.enableDataItem(child, maxDepth, depth + 1, duration);
            } else {
              this.disableDataItem(child);
            }
          } else {
            this.enableDataItem(child, maxDepth, depth + 1, duration);
          }
        });
      } else {
        each(children, (child) => {
          if (!child.isHidden()) {
            child.get("node").show(duration);
            child.get("node").states.applyAnimate("disabled");
            child.set("disabled", true);
            this.disableDataItem(child);
          }
        });
      }
    }
  }
  /**
   * Disables a data item.
   *
   * @param  dataItem  Target data item
   * @param  duration  Animation duration in milliseconds
   */
  disableDataItem(dataItem, duration) {
    dataItem.set("disabled", true);
    let children = dataItem.get("children");
    if (children) {
      each(children, (child) => {
        this.disableDataItem(child, duration);
        child.get("node").hide(duration);
      });
    }
  }
  _selectDataItem(dataItem, downDepth, skipDisptach) {
    if (dataItem) {
      if (!skipDisptach) {
        const type = "dataitemselected";
        this.events.dispatch(type, { type, target: this, dataItem });
      }
      let maxDepth = this.getPrivate("maxDepth", 1);
      const topDepth = this.get("topDepth", 0);
      if (downDepth == null) {
        downDepth = Math.min(this.get("downDepth", 1), maxDepth - dataItem.get("depth"));
      }
      if (!this.inited) {
        downDepth = Math.min(this.get("initialDepth", 1), maxDepth - topDepth);
      }
      this._currentDownDepth = downDepth;
      const hierarchyNode = dataItem.get("d3HierarchyNode");
      let currentDepth = hierarchyNode.depth;
      if (currentDepth + downDepth > maxDepth) {
        downDepth = maxDepth - currentDepth;
      }
      if (currentDepth < topDepth) {
        downDepth += topDepth - currentDepth;
        currentDepth = topDepth;
      }
      const children = dataItem.get("children");
      if (children && children.length > 0) {
        if (downDepth > 0) {
          this.enableDataItem(dataItem, downDepth);
        } else {
          dataItem.get("node").show();
          each(children, (child) => {
            child.get("node").hide();
          });
        }
        if (hierarchyNode.depth < topDepth) {
          dataItem.get("node").hide(0);
        }
        if (this.get("singleBranchOnly")) {
          this._handleSingle(dataItem);
        }
      } else {
        this.enableDataItem(this.dataItems[0], downDepth, 0);
      }
      this._root.events.once("frameended", () => {
        this._zoom(dataItem);
      });
    }
  }
  _zoom(_dataItem) {
  }
  _handleSingle(dataItem) {
    const parent = dataItem.get("parent");
    if (parent) {
      const children = parent.get("children");
      if (children) {
        each(children, (child) => {
          if (child != dataItem) {
            this.disableDataItem(child);
          }
        });
      }
    }
  }
  /**
   * Selects specific data item.
   *
   * @param  dataItem  Target data item
   */
  selectDataItem(dataItem) {
    const parent = dataItem.get("parent");
    const maxDepth = this.getPrivate("maxDepth", 1);
    if (this.get("selectedDataItem") == dataItem) {
      if (parent) {
        this.set("selectedDataItem", parent);
      } else {
        let depth = Math.min(this.get("downDepth", 1), maxDepth - dataItem.get("depth"));
        if (this._currentDownDepth == depth) {
          depth = Math.min(this.get("initialDepth", 1), maxDepth - this.get("topDepth", 0));
        }
        this._selectDataItem(dataItem, depth);
      }
    } else {
      this.set("selectedDataItem", dataItem);
    }
  }
  _makeBullet(dataItem, bulletFunction, index3) {
    const bullet = super._makeBullet(dataItem, bulletFunction, index3);
    if (bullet) {
      const sprite = bullet.get("sprite");
      const node = dataItem.get("node");
      if (sprite) {
        node.children.push(sprite);
        node.on("width", () => {
          this._positionBullet(bullet);
        });
        node.on("height", () => {
          this._positionBullet(bullet);
        });
      }
    }
    return bullet;
  }
  _positionBullet(bullet) {
    const sprite = bullet.get("sprite");
    if (sprite) {
      const dataItem = sprite.dataItem;
      const locationX = bullet.get("locationX", 0.5);
      const locationY = bullet.get("locationY", 0.5);
      const node = dataItem.get("node");
      sprite.set("x", node.width() * locationX);
      sprite.set("y", node.height() * locationY);
    }
  }
  /**
   * Triggers hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  hoverDataItem(dataItem) {
    const node = dataItem.get("node");
    if (node && !node.isHidden()) {
      node.hover();
    }
  }
  /**
   * Triggers un-hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  unhoverDataItem(dataItem) {
    const node = dataItem.get("node");
    if (node) {
      node.unhover();
    }
  }
};
Object.defineProperty(Hierarchy, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Hierarchy"
});
Object.defineProperty(Hierarchy, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Series.classNames.concat([Hierarchy.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/LinkedHierarchyNode.js
var LinkedHierarchyNode = class extends HierarchyNode {
  _afterNew() {
    super._afterNew();
    this.states.create("disabled", {});
    this.states.create("hover", {});
    this.states.create("hoverDisabled", {});
  }
  _updateLinks(duration) {
    const dataItem = this.dataItem;
    if (dataItem) {
      let links = dataItem.get("links");
      each(links, (link) => {
        let source = link.get("source");
        let target = link.get("target");
        if (source && target) {
          if (source.get("node").isHidden() || target.get("node").isHidden()) {
            link.hide(duration);
          } else {
            link.show(duration);
          }
        }
      });
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("disabled")) {
      this._updateLinks();
    }
  }
  _onHide(duration) {
    super._onHide(duration);
    this._updateLinks(duration);
  }
  _onShow(duration) {
    super._onShow(duration);
    this._updateLinks(duration);
  }
};
Object.defineProperty(LinkedHierarchyNode, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "LinkedHierarchyNode"
});
Object.defineProperty(LinkedHierarchyNode, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: HierarchyNode.classNames.concat([LinkedHierarchyNode.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/HierarchyLink.js
var HierarchyLink = class extends Graphics {
  _changed() {
    super._changed();
    if (this._clear) {
      let source = this.get("source");
      let target = this.get("target");
      if (source && target) {
        const sourceNode = source.get("node");
        const targetNode = target.get("node");
        this._display.moveTo(sourceNode.x(), sourceNode.y());
        this._display.lineTo(targetNode.x(), targetNode.y());
      }
    }
  }
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("source")) {
      const source = this.get("source");
      if (source) {
        const sourceNode = source.get("node");
        sourceNode.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        });
      }
    }
    if (this.isDirty("target")) {
      const target = this.get("target");
      if (target) {
        const targetNode = target.get("node");
        targetNode.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        });
      }
    }
  }
};
Object.defineProperty(HierarchyLink, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "HierarchyLink"
});
Object.defineProperty(HierarchyLink, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Graphics.classNames.concat([HierarchyLink.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/LinkedHierarchy.js
var LinkedHierarchy = class extends Hierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "nodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => LinkedHierarchyNode._new(this._root, {
        themeTags: mergeTags(this.nodes.template.get("themeTags", []), [this._tag, "linkedhierarchy", "hierarchy", "node"]),
        x: this.width() / 2,
        y: this.height() / 2
      }, [this.nodes.template]))
    });
    Object.defineProperty(this, "circles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Circle._new(this._root, {
        themeTags: mergeTags(this.circles.template.get("themeTags", []), [this._tag, "shape"])
      }, [this.circles.template]))
    });
    Object.defineProperty(this, "outerCircles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Circle._new(this._root, {
        themeTags: mergeTags(this.outerCircles.template.get("themeTags", []), [this._tag, "outer", "shape"])
      }, [this.outerCircles.template]))
    });
    Object.defineProperty(this, "links", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => HierarchyLink._new(this._root, {
        themeTags: mergeTags(this.links.template.get("themeTags", []), [this._tag, "linkedhierarchy", "hierarchy", "link"])
      }, [this.links.template]))
    });
    Object.defineProperty(this, "linksContainer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.children.moveValue(Container.new(this._root, {}), 0)
    });
  }
  _afterNew() {
    this.fields.push("linkWith", "x", "y");
    super._afterNew();
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const node = super.makeNode(dataItem);
    const circle = node.children.moveValue(this.circles.make(), 0);
    this.circles.push(circle);
    node.setPrivate("tooltipTarget", circle);
    dataItem.setRaw("circle", circle);
    const outerCircle = node.children.moveValue(this.outerCircles.make(), 0);
    this.outerCircles.push(outerCircle);
    dataItem.setRaw("outerCircle", outerCircle);
    const label = dataItem.get("label");
    circle.on("radius", () => {
      const d2 = circle.get("radius", this.width()) * 2;
      label.setAll({ maxWidth: d2, maxHeight: d2 });
      outerCircle.set("radius", d2 / 2);
      this._handleRadiusChange();
    });
    const d = circle.get("radius", this.width()) * 2;
    label.setAll({ maxWidth: d, maxHeight: d });
    circle._setDataItem(dataItem);
    outerCircle._setDataItem(dataItem);
    return node;
  }
  _handleRadiusChange() {
  }
  processDataItem(dataItem) {
    dataItem.setRaw("childLinks", []);
    dataItem.setRaw("links", []);
    super.processDataItem(dataItem);
  }
  _processDataItem(dataItem) {
    super._processDataItem(dataItem);
    const parentDataItem = dataItem.get("parent");
    if (parentDataItem && parentDataItem.get("depth") >= this.get("topDepth")) {
      const link = this.linkDataItems(parentDataItem, dataItem);
      dataItem.setRaw("parentLink", link);
    }
    const node = dataItem.get("node");
    this.updateLinkWith(this.dataItems);
    node._updateLinks(0);
  }
  /**
   * @ignore
   */
  updateLinkWith(dataItems) {
    each(dataItems, (dataItem) => {
      const linkWith = dataItem.get("linkWith");
      if (linkWith) {
        each(linkWith, (id) => {
          const linkWithDataItem = this._getDataItemById(this.dataItems, id);
          if (linkWithDataItem) {
            this.linkDataItems(dataItem, linkWithDataItem);
          }
        });
      }
      const children = dataItem.get("children");
      if (children) {
        this.updateLinkWith(children);
      }
    });
  }
  _getPoint(hierarchyNode) {
    return { x: hierarchyNode.x, y: hierarchyNode.y };
  }
  _animatePositions(dataItem) {
    const node = dataItem.get("node");
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const point = this._getPoint(hierarchyNode);
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    node.animate({ key: "x", to: point.x, duration, easing });
    node.animate({ key: "y", to: point.y, duration, easing });
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    this._animatePositions(dataItem);
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const hierarchyChildren = hierarchyNode.children;
    if (hierarchyChildren) {
      each(hierarchyChildren, (hierarchyChild) => {
        this._updateNodes(hierarchyChild);
      });
    }
    const fill = dataItem.get("fill");
    const circle = dataItem.get("circle");
    const children = dataItem.get("children");
    if (circle) {
      circle._setDefault("fill", fill);
      circle._setDefault("stroke", fill);
    }
    const outerCircle = dataItem.get("outerCircle");
    if (outerCircle) {
      outerCircle._setDefault("fill", fill);
      outerCircle._setDefault("stroke", fill);
      if (!children || children.length == 0) {
        outerCircle.setPrivate("visible", false);
      }
    }
  }
  /**
   * Link two data items with a link element.
   *
   * @param   source    Source node data item
   * @param   target    Target node data item
   * @param   strength  Link strength
   * @return            Link element
   */
  linkDataItems(source, target, strength) {
    let link;
    const sourceLinks = source.get("links");
    if (sourceLinks) {
      each(sourceLinks, (lnk) => {
        if (lnk.get("target") == target) {
          link = lnk;
        }
      });
    }
    const targetLinks = target.get("links");
    if (targetLinks) {
      each(targetLinks, (lnk) => {
        if (lnk.get("target") == source) {
          link = lnk;
        }
      });
    }
    if (!link) {
      link = this.links.make();
      this.links.push(link);
      this.linksContainer.children.push(link);
      link.set("source", source);
      link.set("target", target);
      link._setDataItem(source);
      link.set("stroke", source.get("fill"));
      if (strength != null) {
        link.set("strength", strength);
      }
      source.get("childLinks").push(link);
      move(source.get("links"), link);
      move(target.get("links"), link);
      this._processLink(link, source, target);
    }
    return link;
  }
  /**
   * Unlink two linked data items.
   *
   * @param   source  Source node data item
   * @param   target  Target node data item
   */
  unlinkDataItems(source, target) {
    let link;
    const sourceLinks = source.get("links");
    if (sourceLinks) {
      each(sourceLinks, (lnk) => {
        if (lnk && lnk.get("target") == target) {
          link = lnk;
          remove(sourceLinks, link);
        }
      });
    }
    const targetLinks = target.get("links");
    if (targetLinks) {
      each(targetLinks, (lnk) => {
        if (lnk && lnk.get("target") == source) {
          link = lnk;
          remove(targetLinks, link);
        }
      });
    }
    if (link) {
      this._disposeLink(link);
    }
    this._handleUnlink();
  }
  _handleUnlink() {
  }
  _disposeLink(link) {
    this.links.removeValue(link);
    link.dispose();
  }
  /**
   * Returns `true` if two nodes are linked with each other.
   */
  areLinked(source, target) {
    const sourceLinks = source.get("links");
    let linked = false;
    if (sourceLinks) {
      each(sourceLinks, (lnk) => {
        if (lnk.get("target") == target) {
          linked = true;
        }
      });
    }
    const targetLinks = target.get("links");
    if (targetLinks) {
      each(targetLinks, (lnk) => {
        if (lnk.get("target") == source) {
          linked = true;
        }
      });
    }
    return linked;
  }
  _processLink(_link, _source, _target) {
  }
  /**
   * @ignore
   */
  disposeDataItem(dataItem) {
    super.disposeDataItem(dataItem);
    const links = dataItem.get("links");
    if (links) {
      each(links, (link) => {
        this._disposeLink(link);
      });
    }
  }
  /**
   * Select a data item.
   * @param  dataItem  Data item
   */
  selectDataItem(dataItem) {
    const parent = dataItem.get("parent");
    if (!dataItem.get("disabled")) {
      this.set("selectedDataItem", dataItem);
    } else {
      if (parent) {
        this.setRaw("selectedDataItem", parent);
        const type = "dataitemselected";
        this.events.dispatch(type, { type, target: this, dataItem: parent });
        this.disableDataItem(dataItem);
      }
    }
  }
};
Object.defineProperty(LinkedHierarchy, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "LinkedHierarchy"
});
Object.defineProperty(LinkedHierarchy, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Hierarchy.classNames.concat([LinkedHierarchy.className])
});

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x3 = +this._x.call(null, d), y3 = +this._y.call(null, d);
  return add(this.cover(x3, y3), x3, y3, d);
}
function add(tree, x3, y3, d) {
  if (isNaN(x3) || isNaN(y3))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x3 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n = data.length, x3, y3, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x3 = +this._x.call(null, d = data[i])) || isNaN(y3 = +this._y.call(null, d)))
      continue;
    xz[i] = x3;
    yz[i] = y3;
    if (x3 < x0)
      x0 = x3;
    if (x3 > x1)
      x1 = x3;
    if (y3 < y0)
      y0 = y3;
    if (y3 > y1)
      y1 = y3;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
    y1 = (y0 = Math.floor(y3)) + 1;
  } else {
    var z = x1 - x0 || 1, node = this._root, parent, i;
    while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
      i = (y3 < y0) << 1 | x3 < x0;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x1 = x0 + z, y1 = y0 + z;
          break;
        case 1:
          x0 = x1 - z, y1 = y0 + z;
          break;
        case 2:
          x1 = x0 + z, y0 = y1 - z;
          break;
        case 3:
          x0 = x1 - z, y0 = y1 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default2(x3, y3, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x3 - radius, y0 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i = (y3 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x3 - d, y0 = y3 - d;
        x32 = x3 + d, y32 = y3 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x3 = +this._x.call(null, d)) || isNaN(y3 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x3 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i)
    this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x0, y0, x1, y1) {
  this._x = x3;
  this._y = y3;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy;
  if (!node.length)
    return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default2;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default2(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x(d) {
  return d.x + d.vx;
}
function y(d) {
  return d.y + d.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function")
    radius = constant_default2(radius == null ? 1 : +radius);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x3 = xi - data.x - data.vx, y3 = yi - data.y - data.vy, l = x3 * x3 + y3 * y3;
          if (l < r * r) {
            if (x3 === 0)
              x3 = jiggle_default(random), l += x3 * x3;
            if (y3 === 0)
              y3 = jiggle_default(random), l += y3 * y3;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x3 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y3 *= l) * r;
            data.vx -= x3 * (r = 1 - r);
            data.vy -= y3 * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d) {
  return d.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id = index, strength = defaultStrength, strengths, distance = constant_default2(30), distances, nodes, count3, bias, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count3[link.source.index], count3[link.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x3, y3, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l = Math.sqrt(x3 * x3 + y3 * y3);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x3 *= l, y3 *= l;
        target.vx -= x3 * (b = bias[i]);
        target.vy -= y3 * b;
        source.vx += x3 * (b = 1 - b);
        source.vy += y3 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id(d, i2, nodes), d])), link;
    for (i = 0, count3 = new Array(n); i < m3; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object")
        link.source = find(nodeById, link.source);
      if (typeof link.target !== "object")
        link.target = find(nodeById, link.target);
      count3[link.source.index] = (count3[link.source.index] || 0) + 1;
      count3[link.target.index] = (count3[link.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m3); i < m3; ++i) {
      link = links[i], bias[i] = count3[link.source.index] / (count3[link.source.index] + count3[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default2(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default2(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c3; i < n; ++i) {
    if ((c3 = type[i]).name === name) {
      return c3.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a2 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s = 1;
  return () => (s = (a2 * s + c2) % m2) / m2;
}

// node_modules/d3-force/src/simulation.js
function x2(d) {
  return d.x;
}
function y2(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default2();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i, n = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function(x3, y3, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x3 - node.x;
        dy = y3 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default2(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c3, weight = 0, x3, y3, i;
    if (quad.length) {
      for (x3 = y3 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c3 = Math.abs(q.value))) {
          strength2 += q.value, weight += c3, x3 += c3 * q.x, y3 += c3 * q.y;
        }
      }
      quad.x = x3 / weight;
      quad.y = y3 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _, x22) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x1, l = x3 * x3 + y3 * y3;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle_default(random), l += x3 * x3;
        if (y3 === 0)
          y3 = jiggle_default(random), l += y3 * y3;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * quad.value * alpha / l;
        node.vy += y3 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0)
        x3 = jiggle_default(random), l += x3 * x3;
      if (y3 === 0)
        y3 = jiggle_default(random), l += y3 * y3;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x3 * w;
        node.vy += y3 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default2(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function")
    x3 = constant_default2(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x3 = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y3) {
  var strength = constant_default2(0.1), nodes, strengths, yz;
  if (typeof y3 !== "function")
    y3 = constant_default2(y3 == null ? 0 : +y3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y3 = typeof _ === "function" ? _ : constant_default2(+_), initialize(), force) : y3;
  };
  return force;
}

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/ForceDirected.js
var ForceDirected = class extends LinkedHierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "forcedirected"
    });
    Object.defineProperty(this, "d3forceSimulation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: simulation_default()
    });
    Object.defineProperty(this, "collisionForce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: collide_default(20)
    });
    Object.defineProperty(this, "linkForce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: link_default()
    });
    Object.defineProperty(this, "_nodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "_links", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "_tick", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "_nodesDirty", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  _afterNew() {
    super._afterNew();
    this.d3forceSimulation.on("tick", () => {
      this._tick++;
      this.updateNodePositions();
    });
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("showOnFrame")) {
      const showOnFrame = this.get("showOnFrame");
      if (showOnFrame > this._tick) {
        this.nodesContainer.setPrivate("visible", false);
        this.linksContainer.setPrivate("visible", false);
      }
    }
    const d3forceSimulation = this.d3forceSimulation;
    if (this.isDirty("velocityDecay")) {
      d3forceSimulation.velocityDecay(this.get("velocityDecay", 0));
    }
    if (this.isDirty("initialFrames")) {
      d3forceSimulation.alphaDecay(1 - Math.pow(1e-3, 1 / this.get("initialFrames", 500)));
    }
  }
  /**
   * @ignore
   */
  restartSimulation(alpha) {
    const d3forceSimulation = this.d3forceSimulation;
    if (d3forceSimulation.alpha() < 0.25) {
      d3forceSimulation.alpha(alpha);
      d3forceSimulation.restart();
    }
  }
  _handleRadiusChange() {
    this._updateForces();
  }
  processDataItem(dataItem) {
    const d3ForceNode = { index: this._index, x: this.innerWidth() / 2, y: this.innerHeight() / 2, dataItem };
    const index3 = this._nodes.push(d3ForceNode) - 1;
    d3ForceNode.index = index3;
    this.d3forceSimulation.nodes(this._nodes);
    dataItem.set("d3ForceNode", d3ForceNode);
    super.processDataItem(dataItem);
    const node = dataItem.get("node");
    node.set("x", -1e4);
    node.on("scale", () => {
      this._updateForces();
    });
    node.events.on("dragged", () => {
      d3ForceNode.fx = node.x();
      d3ForceNode.fy = node.y();
      this._updateForces();
    });
    node.events.on("dragstop", () => {
      if (dataItem.get("x") == null) {
        d3ForceNode.fx = void 0;
      }
      if (dataItem.get("y") == null) {
        d3ForceNode.fy = void 0;
      }
    });
  }
  _updateValues(d3HierarchyNode) {
    super._updateValues(d3HierarchyNode);
    this._nodesDirty = true;
    const d3forceSimulation = this.d3forceSimulation;
    d3forceSimulation.force("collision", this.collisionForce);
    d3forceSimulation.nodes(this._nodes);
    this.linkForce = link_default(this._links);
    d3forceSimulation.force("link", this.linkForce);
  }
  _updateVisuals() {
    super._updateVisuals();
    this.restartSimulation(0.3);
  }
  _updateChildren() {
    super._updateChildren();
    const d3forceSimulation = this.d3forceSimulation;
    if (this._sizeDirty) {
      let w = Math.max(50, this.innerWidth());
      let h = Math.max(50, this.innerHeight());
      let pt = this.get("paddingTop", 0);
      let pl = this.get("paddingLeft", 0);
      let centerStrength = this.get("centerStrength", 1);
      d3forceSimulation.force("x", x_default2().x(w / 2 + pl).strength(centerStrength * 100 / w));
      d3forceSimulation.force("y", y_default2().y(h / 2 + pt).strength(centerStrength * 100 / h));
    }
    if (this._nodesDirty) {
      this._updateForces();
    }
  }
  _updateForces() {
    const d3forceSimulation = this.d3forceSimulation;
    d3forceSimulation.force("manybody", manyBody_default().strength((d3node) => {
      let dataItem = d3node.dataItem;
      let node = dataItem.get("node");
      let circle = dataItem.get("circle");
      let manyBodyStrength = this.get("manyBodyStrength", -15);
      if (circle) {
        return circle.get("radius", 1) * node.get("scale", 1) * manyBodyStrength;
      }
      return 0;
    }));
    this.collisionForce.radius((d3node) => {
      let dataItem = d3node.dataItem;
      let node = dataItem.get("node");
      let circle = dataItem.get("circle");
      let outerCircle = dataItem.get("outerCircle");
      if (circle && outerCircle) {
        let radius = circle.get("radius", 1);
        if (!outerCircle.isHidden()) {
          radius = radius * outerCircle.get("scale", 1.1);
        }
        radius *= node.get("scale", 1);
        return radius + this.get("nodePadding", 0);
      }
    });
    this.restartSimulation(0.3);
  }
  _animatePositions(_dataItem) {
  }
  _clearDirty() {
    super._clearDirty();
    this._nodesDirty = false;
  }
  /**
   * @ignore
   */
  updateNodePositions() {
    const linkForce = this.linkForce;
    if (linkForce) {
      linkForce.distance((linkDatum) => {
        return this.getDistance(linkDatum);
      });
      linkForce.strength((linkDatum) => {
        return this.getStrength(linkDatum);
      });
    }
    if (this._tick == this.get("showOnFrame")) {
      this.nodesContainer.setPrivate("visible", true);
      this.linksContainer.setPrivate("visible", true);
    }
    let d3Nodes = this.d3forceSimulation.nodes();
    each(d3Nodes, (d3Node) => {
      const dataItem = d3Node.dataItem;
      const node = dataItem.get("node");
      node.set("x", d3Node.x);
      node.set("y", d3Node.y);
    });
  }
  /**
   * @ignore
   */
  updateLinkWith(dataItems) {
    each(dataItems, (dataItem) => {
      const linkWith = dataItem.get("linkWith");
      if (linkWith) {
        each(linkWith, (id) => {
          const linkWithDataItem = this._getDataItemById(this.dataItems, id);
          if (linkWithDataItem) {
            this.linkDataItems(dataItem, linkWithDataItem, this.get("linkWithStrength"));
          }
        });
      }
      const children = dataItem.get("children");
      if (children) {
        this.updateLinkWith(children);
      }
    });
  }
  /**
   * @ignore
   */
  getDistance(linkDatum) {
    let sourceDataItem = linkDatum.sourceDataItem;
    let targetDataItem = linkDatum.targetDataItem;
    let distance = 0;
    if (sourceDataItem && targetDataItem) {
      const targetNode = targetDataItem.get("node");
      if (targetNode.isHidden()) {
        return 0;
      }
      let link = linkDatum.link;
      if (link) {
        distance = link.get("distance", 1);
      }
      const sourceNode = sourceDataItem.get("node");
      if (targetNode.isHidden()) {
        distance = 1;
      }
      return distance * (sourceDataItem.get("circle").get("radius", 1) * sourceNode.get("scale", 1) + targetDataItem.get("circle").get("radius", 1) * targetNode.get("scale", 1));
    }
    return distance;
  }
  /**
   * @ignore
   */
  getStrength(linkDatum) {
    let strength = 0;
    let link = linkDatum.link;
    if (link) {
      strength = link.get("strength", 1);
    }
    const targetDataItem = linkDatum.targetDataItem;
    strength *= targetDataItem.get("node").get("scale");
    return strength;
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    this._updateRadius(dataItem);
    const x3 = dataItem.get("x");
    const y3 = dataItem.get("y");
    const d3Node = dataItem.get("d3ForceNode");
    if (x3 != null) {
      d3Node.fx = relativeToValue(x3, this.innerWidth());
    } else {
      d3Node.fx = void 0;
    }
    if (y3 != null) {
      d3Node.fy = relativeToValue(y3, this.innerHeight());
    } else {
      d3Node.fx = void 0;
    }
  }
  _updateRadius(dataItem) {
    let size = (this.innerWidth() + this.innerHeight()) / 2;
    let minRadius = relativeToValue(this.get("minRadius", 1), size);
    let maxRadius = relativeToValue(this.get("maxRadius", 5), size);
    let valueWorking = dataItem.get("sum");
    let radius = maxRadius;
    const min2 = this.getPrivate("valueLow", 0);
    const max2 = this.getPrivate("valueHigh", 0);
    if (max2 > 0) {
      radius = minRadius + (valueWorking - min2) / (max2 - min2) * (maxRadius - minRadius);
    }
    if (!isNumber(radius)) {
      radius = minRadius;
    }
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    dataItem.get("circle").animate({ key: "radius", to: radius, duration, easing });
  }
  _processLink(link, source, target) {
    const d3Link = { link, source: source.get("d3ForceNode").index, target: target.get("d3ForceNode").index, sourceDataItem: source, targetDataItem: target };
    this._links.push(d3Link);
    link.setPrivate("d3Link", d3Link);
    this.linkForce = link_default(this._links);
    this.d3forceSimulation.force("link", this.linkForce);
    this.restartSimulation(0.5);
  }
  _disposeLink(link) {
    super._disposeLink(link);
    remove(this._links, link.getPrivate("d3Link"));
  }
  _handleUnlink() {
    this.restartSimulation(0.5);
  }
  _onDataClear() {
    super._onDataClear();
    this._nodes = [];
    this._links = [];
  }
};
Object.defineProperty(ForceDirected, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "ForceDirected"
});
Object.defineProperty(ForceDirected, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: LinkedHierarchy.classNames.concat([ForceDirected.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Pack.js
var Pack = class extends Hierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "pack"
    });
    Object.defineProperty(this, "_packLayout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: pack_default()
    });
    Object.defineProperty(this, "_packData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "circles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Circle._new(this._root, {
        themeTags: mergeTags(this.circles.template.get("themeTags", []), [this._tag, "shape"])
      }, [this.circles.template]))
    });
  }
  _afterNew() {
    super._afterNew();
    this.setPrivate("scaleR", 1);
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isPrivateDirty("scaleR")) {
      if (this._rootNode) {
        this._updateNodesScale(this._rootNode);
      }
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      const packLayout = this._packLayout;
      packLayout.size([this.innerWidth(), this.innerHeight()]);
      packLayout(this._rootNode);
      packLayout.padding(this.get("nodePadding", 0));
      this._updateNodes(this._rootNode);
    }
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    const node = dataItem.get("node");
    const circle = dataItem.get("circle");
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const scaleR = this.getPrivate("scaleR", 1);
    const x3 = hierarchyNode.x * scaleR;
    const y3 = hierarchyNode.y * scaleR;
    const radius = hierarchyNode.r * scaleR;
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    node.animate({ key: "x", to: x3, duration, easing });
    node.animate({ key: "y", to: y3, duration, easing });
    if (circle) {
      const fill = dataItem.get("fill");
      circle.animate({ key: "radius", to: radius, duration, easing });
      circle._setDefault("fill", fill);
      circle._setDefault("stroke", fill);
    }
  }
  _updateNodesScale(hierarchyNode) {
    const dataItem = hierarchyNode.data.dataItem;
    if (dataItem) {
      const node = dataItem.get("node");
      const circle = dataItem.get("circle");
      const scaleR = this.getPrivate("scaleR", 1);
      const x3 = hierarchyNode.x * scaleR;
      const y3 = hierarchyNode.y * scaleR;
      const radius = hierarchyNode.r * scaleR;
      node.setAll({ x: x3, y: y3 });
      circle.set("radius", radius);
      const hierarchyChildren = hierarchyNode.children;
      if (hierarchyChildren) {
        each(hierarchyChildren, (hierarchyChild) => {
          this._updateNodesScale(hierarchyChild);
        });
      }
    }
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const node = super.makeNode(dataItem);
    const circle = node.children.moveValue(this.circles.make(), 0);
    node.setPrivate("tooltipTarget", circle);
    this.circles.push(circle);
    dataItem.setRaw("circle", circle);
    const label = dataItem.get("label");
    circle.on("radius", () => {
      const d = circle.get("radius", this.width()) * 2;
      label.setAll({ maxWidth: d, maxHeight: d });
    });
    return node;
  }
  _zoom(dataItem) {
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    let x3 = hierarchyNode.x;
    let y3 = hierarchyNode.y;
    let r = hierarchyNode.r;
    let scaleR = Math.min(this.innerWidth(), this.innerHeight()) / (r * 2);
    const easing = this.get("animationEasing");
    let duration = this.get("animationDuration", 0);
    if (!this.inited) {
      duration = 0;
    }
    this.animatePrivate({ key: "scaleR", to: scaleR, duration, easing });
    const nodesContainer = this.nodesContainer;
    nodesContainer.animate({ key: "x", from: nodesContainer.x(), to: this.width() / 2 - x3 * scaleR, duration, easing });
    nodesContainer.animate({ key: "y", from: nodesContainer.y(), to: this.height() / 2 - y3 * scaleR, duration, easing });
  }
};
Object.defineProperty(Pack, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Pack"
});
Object.defineProperty(Pack, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Hierarchy.classNames.concat([Pack.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Partition.js
var Partition = class extends Hierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "partition"
    });
    Object.defineProperty(this, "rectangles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
        themeTags: mergeTags(this.rectangles.template.get("themeTags", []), [this._tag, "shape"])
      }, [this.rectangles.template]))
    });
    Object.defineProperty(this, "_partitionLayout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: partition_default()
    });
  }
  _afterNew() {
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["partition", this._settings.orientation || "vertical"]);
    super._afterNew();
    this.setPrivate("scaleX", 1);
    this.setPrivate("scaleY", 1);
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("nodePadding")) {
      if (this._rootNode) {
        this._updateNodes(this._rootNode);
      }
    }
    if (this.isPrivateDirty("scaleX") || this.isPrivateDirty("scaleY")) {
      if (this._rootNode) {
        this._updateNodesScale(this._rootNode);
      }
    }
    if (this.isDirty("orientation")) {
      this._updateVisuals();
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      const partitionLayout = this._partitionLayout;
      let w = this.innerWidth();
      let h = this.innerHeight();
      if (this.get("orientation") == "horizontal") {
        [w, h] = [h, w];
      }
      partitionLayout.size([w, h]);
      const nodePadding = this.get("nodePadding");
      if (isNumber(nodePadding)) {
        partitionLayout.padding(nodePadding);
      }
      partitionLayout(this._rootNode);
      this._updateNodes(this._rootNode);
    }
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    const node = dataItem.get("node");
    const rectangle = dataItem.get("rectangle");
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const scaleX = this.getPrivate("scaleX", 1);
    const scaleY = this.getPrivate("scaleY", 1);
    let x0, x1, y0, y1;
    if (this.get("orientation") == "horizontal") {
      x0 = hierarchyNode.y0 * scaleX;
      x1 = hierarchyNode.y1 * scaleX;
      y0 = hierarchyNode.x0 * scaleY;
      y1 = hierarchyNode.x1 * scaleY;
    } else {
      x0 = hierarchyNode.x0 * scaleX;
      x1 = hierarchyNode.x1 * scaleX;
      y0 = hierarchyNode.y0 * scaleY;
      y1 = hierarchyNode.y1 * scaleY;
    }
    let w = x1 - x0;
    let h = y1 - y0;
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    node.animate({ key: "x", to: x0, duration, easing });
    node.animate({ key: "y", to: y0, duration, easing });
    node.animate({ key: "width", to: w, duration, easing });
    node.animate({ key: "height", to: h, duration, easing });
    if (rectangle) {
      const fill = dataItem.get("fill");
      rectangle.animate({ key: "width", to: w, duration, easing });
      rectangle.animate({ key: "height", to: h, duration, easing });
      rectangle._setDefault("fill", fill);
      rectangle._setDefault("stroke", fill);
    }
  }
  _updateNodesScale(hierarchyNode) {
    const dataItem = hierarchyNode.data.dataItem;
    if (dataItem) {
      const node = dataItem.get("node");
      const rectangle = dataItem.get("rectangle");
      const scaleX = this.getPrivate("scaleX", 1);
      const scaleY = this.getPrivate("scaleY", 1);
      let x0, x1, y0, y1;
      if (this.get("orientation") == "horizontal") {
        x0 = hierarchyNode.y0 * scaleX;
        x1 = hierarchyNode.y1 * scaleX;
        y0 = hierarchyNode.x0 * scaleY;
        y1 = hierarchyNode.x1 * scaleY;
      } else {
        x0 = hierarchyNode.x0 * scaleX;
        x1 = hierarchyNode.x1 * scaleX;
        y0 = hierarchyNode.y0 * scaleY;
        y1 = hierarchyNode.y1 * scaleY;
      }
      const w = x1 - x0;
      const h = y1 - y0;
      node.setAll({ x: x0, y: y0, width: w, height: h });
      rectangle.setAll({ width: w, height: h });
      const hierarchyChildren = hierarchyNode.children;
      if (hierarchyChildren) {
        each(hierarchyChildren, (hierarchyChild) => {
          this._updateNodesScale(hierarchyChild);
        });
      }
    }
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const node = super.makeNode(dataItem);
    this._makeNode(dataItem, node);
    return node;
  }
  _makeNode(dataItem, node) {
    const rectangle = node.children.moveValue(this.rectangles.make(), 0);
    node.setPrivate("tooltipTarget", rectangle);
    dataItem.setRaw("rectangle", rectangle);
    rectangle._setDataItem(dataItem);
    const label = dataItem.get("label");
    rectangle.on("width", () => {
      label.set("maxWidth", rectangle.width());
    });
    rectangle.on("height", () => {
      label.set("maxHeight", rectangle.height());
    });
  }
  _zoom(dataItem) {
    let x0 = 0;
    let x1 = 0;
    let y0 = 0;
    let y1 = 0;
    const upDepth = this.get("upDepth", 0) + 1;
    const topDepth = this.get("topDepth", 0);
    const width = this.innerWidth();
    const height = this.innerHeight();
    const maxDepth = this.getPrivate("maxDepth", 1);
    const levelHeight = height / (maxDepth + 1);
    const levelWidth = width / (maxDepth + 1);
    const initialDepth = Math.min(this.get("initialDepth", 1), maxDepth - topDepth);
    let downDepth = this._currentDownDepth;
    if (downDepth == null) {
      downDepth = this.get("downDepth", 1);
    }
    if (dataItem) {
      const hierarchyNode = dataItem.get("d3HierarchyNode");
      let currentDepth = hierarchyNode.depth;
      if (this.get("orientation") == "horizontal") {
        x0 = hierarchyNode.y0;
        x1 = hierarchyNode.y1;
        y0 = hierarchyNode.x0;
        y1 = hierarchyNode.x1;
        x0 = x1 - levelWidth * upDepth;
        x1 = x0 + levelWidth * (downDepth + 1);
        if (currentDepth < topDepth) {
          y0 = 0;
          y1 = height;
          x0 = levelWidth * topDepth;
          x1 = x0 + levelWidth * initialDepth;
        }
      } else {
        x0 = hierarchyNode.x0;
        x1 = hierarchyNode.x1;
        y0 = hierarchyNode.y0;
        y1 = hierarchyNode.y1;
        y0 = y1 - levelHeight * upDepth;
        y1 = y0 + levelHeight * (downDepth + 1);
        if (currentDepth < topDepth) {
          x0 = 0;
          x1 = width;
          y0 = levelHeight * topDepth;
          y1 = y0 + levelHeight * initialDepth;
        }
      }
    }
    let scaleX = width / (x1 - x0);
    let scaleY = height / (y1 - y0);
    const easing = this.get("animationEasing");
    let duration = this.get("animationDuration", 0);
    if (!this.inited) {
      duration = 0;
    }
    this.animatePrivate({ key: "scaleX", to: scaleX, duration, easing });
    this.animatePrivate({ key: "scaleY", to: scaleY, duration, easing });
    this.nodesContainer.animate({ key: "x", to: -x0 * scaleX, duration, easing });
    this.nodesContainer.animate({ key: "y", to: -y0 * scaleY, duration, easing });
  }
};
Object.defineProperty(Partition, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Partition"
});
Object.defineProperty(Partition, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Hierarchy.classNames.concat([Partition.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Sunburst.js
var Sunburst = class extends Partition {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "sunburst"
    });
    Object.defineProperty(this, "_partitionLayout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: partition_default()
    });
    Object.defineProperty(this, "slices", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Slice._new(this._root, {
        themeTags: mergeTags(this.slices.template.get("themeTags", []), [this._tag, "hierarchy", "node", "shape"])
      }, [this.slices.template]))
    });
    Object.defineProperty(this, "labels", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => RadialLabel._new(this._root, {
        themeTags: mergeTags(this.labels.template.get("themeTags", []), [this._tag])
      }, [this.labels.template]))
    });
  }
  _afterNew() {
    super._afterNew();
    this.nodesContainer.setAll({ x: p50, y: p50 });
    this.setPrivateRaw("dx", 0);
    this.setPrivateRaw("dr", 0);
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isPrivateDirty("dr") || this.isPrivateDirty("dx")) {
      if (this._rootNode) {
        this._updateNodesScale(this._rootNode);
      }
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      const partitionLayout = this._partitionLayout;
      let bounds = getArcBounds(0, 0, this.get("startAngle", 0), this.get("endAngle", 360), 1);
      let w = this.innerWidth();
      let h = this.innerHeight();
      const wr = w / (bounds.right - bounds.left);
      const hr = h / (bounds.bottom - bounds.top);
      let s = Math.min(wr, hr);
      let r = relativeToValue(this.get("radius", p100), s);
      let ir = relativeToValue(this.get("innerRadius", 0), r);
      if (ir < 0) {
        ir = r + ir;
      }
      s = r - ir;
      this.setPrivateRaw("innerRadius", ir);
      this.setPrivateRaw("hierarchySize", s);
      partitionLayout.size([s, s]);
      this.nodesContainer.setAll({
        dy: -r * (bounds.bottom + bounds.top) / 2,
        dx: -r * (bounds.right + bounds.left) / 2
      });
      const nodePadding = this.get("nodePadding");
      if (isNumber(nodePadding)) {
        partitionLayout.padding(nodePadding);
      }
      partitionLayout(this._rootNode);
      this._updateNodes(this._rootNode);
    }
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const node = dataItem.get("node");
    node.setAll({ x: 0, y: 0 });
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    const scaleX = this.getPrivate("scaleX", 1);
    const scaleY = this.getPrivate("scaleY", 1);
    const dr = this.getPrivate("dr", 0);
    const dx = this.getPrivate("dx", 0);
    const x0 = hierarchyNode.x0 * scaleX + dx;
    const x1 = hierarchyNode.x1 * scaleX + dx;
    const y0 = hierarchyNode.y0 * scaleY;
    const y1 = hierarchyNode.y1 * scaleY;
    const ir = this.getPrivate("innerRadius");
    const hs = this.getPrivate("hierarchySize", 0);
    const slice2 = dataItem.get("slice");
    if (slice2) {
      const startAngle = this.get("startAngle", -90);
      const endAngle = this.get("endAngle", 270);
      const sliceStartAngle = startAngle + x0 / hs * (endAngle - startAngle);
      const arc = startAngle + x1 / hs * (endAngle - startAngle) - sliceStartAngle;
      let sliceInnerRadius = ir + y0;
      let sliceRadius = ir + y1;
      sliceInnerRadius -= dr;
      sliceRadius -= dr;
      sliceRadius = Math.max(0, sliceRadius);
      sliceInnerRadius = Math.max(0, sliceInnerRadius);
      slice2.animate({ key: "radius", to: sliceRadius, duration, easing });
      slice2.animate({ key: "innerRadius", to: sliceInnerRadius, duration, easing });
      slice2.animate({ key: "startAngle", to: sliceStartAngle, duration, easing });
      slice2.animate({ key: "arc", to: arc, duration, easing });
      const fill = dataItem.get("fill");
      slice2._setDefault("fill", fill);
      slice2._setDefault("stroke", fill);
    }
  }
  _updateNodesScale(hierarchyNode) {
    const dataItem = hierarchyNode.data.dataItem;
    if (dataItem) {
      const scaleX = this.getPrivate("scaleX", 1);
      const scaleY = this.getPrivate("scaleY", 1);
      const dr = this.getPrivate("dr", 0);
      const dx = this.getPrivate("dx", 0);
      const x0 = hierarchyNode.x0 * scaleX + dx;
      const x1 = hierarchyNode.x1 * scaleX + dx;
      const y0 = hierarchyNode.y0 * scaleY;
      const y1 = hierarchyNode.y1 * scaleY;
      const ir = this.getPrivate("innerRadius");
      const hs = this.getPrivate("hierarchySize", 0);
      const slice2 = dataItem.get("slice");
      if (slice2) {
        const startAngle = this.get("startAngle", -90);
        const endAngle = this.get("endAngle", 270);
        const sliceStartAngle = startAngle + x0 / hs * (endAngle - startAngle);
        const arc = startAngle + x1 / hs * (endAngle - startAngle) - sliceStartAngle;
        let sliceInnerRadius = ir + y0;
        let sliceRadius = ir + y1;
        sliceInnerRadius -= dr;
        sliceRadius -= dr;
        sliceRadius = Math.max(0, sliceRadius);
        sliceInnerRadius = Math.max(0, sliceInnerRadius);
        slice2.setAll({ radius: sliceRadius, innerRadius: sliceInnerRadius, startAngle: sliceStartAngle, arc });
      }
      const hierarchyChildren = hierarchyNode.children;
      if (hierarchyChildren) {
        each(hierarchyChildren, (hierarchyChild) => {
          this._updateNodesScale(hierarchyChild);
        });
      }
    }
  }
  _makeNode(dataItem, node) {
    const slice2 = node.children.moveValue(this.slices.make(), 0);
    node.setPrivate("tooltipTarget", slice2);
    dataItem.setRaw("slice", slice2);
    slice2._setDataItem(dataItem);
    slice2.on("arc", () => {
      this._updateLabel(dataItem);
    });
    slice2.on("innerRadius", () => {
      this._updateLabel(dataItem);
    });
    slice2.on("radius", () => {
      this._updateLabel(dataItem);
    });
  }
  _updateLabel(dataItem) {
    const slice2 = dataItem.get("slice");
    const label = dataItem.get("label");
    if (slice2 && label) {
      let innerRadius = slice2.get("innerRadius", 0);
      let radius = slice2.get("radius", 0);
      let angle = slice2.get("startAngle", 0);
      let arc = Math.abs(slice2.get("arc", 0));
      let labelAngle = angle + arc / 2;
      let textType = label.get("textType");
      let maxWidth = radius - innerRadius;
      let maxHeight = radius * arc * RADIANS;
      if (innerRadius == 0 && arc >= 360 && textType == "radial") {
        radius = 1;
        labelAngle = 0;
        maxWidth *= 2;
        maxHeight = maxWidth;
      }
      if (Math.round(arc) >= 360 && textType == "radial") {
        labelAngle = 0;
      }
      if (textType == "circular") {
        maxWidth = arc * RADIANS * (innerRadius + (radius - innerRadius) / 2) - 10;
      }
      label.setAll({ labelAngle });
      label.setPrivate("radius", radius);
      label.setPrivate("innerRadius", innerRadius);
      label.setAll({
        maxHeight,
        maxWidth
      });
    }
  }
  _zoom(dataItem) {
    let x0 = 0;
    let x1 = 0;
    let hs = this.getPrivate("hierarchySize", 0);
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    let upDepth = this.get("upDepth", 0);
    let topDepth = this.get("topDepth", 0);
    let currentDepth = hierarchyNode.depth;
    let maxDepth = this.getPrivate("maxDepth", 1);
    let downDepth = this._currentDownDepth;
    if (downDepth == null) {
      downDepth = this.get("downDepth", 1);
    }
    const levelHeight = hs / (maxDepth + 1);
    if (currentDepth < topDepth) {
      currentDepth = topDepth;
    }
    if (currentDepth - upDepth < 0) {
      upDepth = currentDepth;
    }
    x0 = hierarchyNode.x0;
    x1 = hierarchyNode.x1;
    let scaleDepth = downDepth + upDepth + 1;
    if (scaleDepth > maxDepth - topDepth + 1) {
      scaleDepth = maxDepth - topDepth + 1;
    }
    let scaleX = hs / (x1 - x0);
    let scaleY = hs / (levelHeight * scaleDepth);
    let dr = Math.max(currentDepth - upDepth, topDepth) * levelHeight * scaleY;
    const easing = this.get("animationEasing");
    let duration = this.get("animationDuration", 0);
    if (!this.inited) {
      duration = 0;
    }
    let dx = -x0 * scaleX;
    this.animatePrivate({ key: "scaleX", to: scaleX, duration, easing });
    this.animatePrivate({ key: "scaleY", to: scaleY, duration, easing });
    this.animatePrivate({ key: "dr", to: dr, duration, easing });
    this.animatePrivate({ key: "dx", to: dx, duration, easing });
  }
  _handleSingle(dataItem) {
    const parent = dataItem.get("parent");
    if (parent) {
      const children = parent.get("children");
      if (children) {
        each(children, (child) => {
          if (child != dataItem) {
            this.disableDataItem(child);
            child.get("node").hide();
          }
        });
      }
      this._handleSingle(parent);
    }
  }
  _positionBullet(bullet) {
    const sprite = bullet.get("sprite");
    if (sprite) {
      const dataItem = sprite.dataItem;
      const locationX = bullet.get("locationX", 0.5);
      const locationY = bullet.get("locationY", 0.5);
      const slice2 = dataItem.get("slice");
      const arc = slice2.get("arc", 0);
      const angle = slice2.get("startAngle", 0) + slice2.get("arc", 0) * locationX;
      const innerRadius = slice2.get("innerRadius", 0);
      const radius = innerRadius + (slice2.get("radius", 0) - innerRadius) * locationY;
      let x3 = cos(angle) * radius;
      let y3 = sin(angle) * radius;
      if (round(arc, 5) === 360 && round(innerRadius, 2) === 0) {
        x3 = 0;
        y3 = 0;
      }
      sprite.set("x", x3);
      sprite.set("y", y3);
    }
  }
  _makeBullet(dataItem, bulletFunction, index3) {
    const bullet = super._makeBullet(dataItem, bulletFunction, index3);
    if (bullet) {
      const sprite = bullet.get("sprite");
      const slice2 = dataItem.get("slice");
      if (sprite && slice2) {
        slice2.on("arc", () => {
          this._positionBullet(bullet);
        });
        slice2.on("radius", () => {
          this._positionBullet(bullet);
        });
      }
      return bullet;
    }
  }
};
Object.defineProperty(Sunburst, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Sunburst"
});
Object.defineProperty(Sunburst, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Partition.classNames.concat([Sunburst.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Tree.js
var Tree = class extends LinkedHierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "tree"
    });
    Object.defineProperty(this, "_hierarchyLayout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree_default()
    });
    Object.defineProperty(this, "_packData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("orientation") || this.isDirty("inversed")) {
      this._updateVisuals();
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      const layout = this._hierarchyLayout;
      if (this.get("orientation") == "vertical") {
        layout.size([this.innerWidth(), this.innerHeight()]);
      } else {
        layout.size([this.innerHeight(), this.innerWidth()]);
      }
      layout(this._rootNode);
    }
    super._updateVisuals();
  }
  _getPoint(hierarchyNode) {
    const inversed = this.get("inversed");
    if (this.get("orientation") == "vertical") {
      if (inversed) {
        return { x: hierarchyNode.x, y: this.innerHeight() - hierarchyNode.y };
      } else {
        return { x: hierarchyNode.x, y: hierarchyNode.y };
      }
    } else {
      if (inversed) {
        return { x: this.innerWidth() - hierarchyNode.y, y: hierarchyNode.x };
      } else {
        return { x: hierarchyNode.y, y: hierarchyNode.x };
      }
    }
  }
};
Object.defineProperty(Tree, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Tree"
});
Object.defineProperty(Tree, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: LinkedHierarchy.classNames.concat([Tree.className])
});

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/Treemap.js
var Treemap = class extends Hierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "treemap"
    });
    Object.defineProperty(this, "rectangleTemplate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Template.new({})
    });
    Object.defineProperty(this, "_treemapLayout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: treemap_default().tile(squarify_default)
    });
    Object.defineProperty(this, "rectangles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
        themeTags: mergeTags(this.rectangles.template.get("themeTags", []), [this._tag, "shape"])
      }, [this.rectangles.template]))
    });
  }
  _afterNew() {
    super._afterNew();
    this.setPrivate("scaleX", 1);
    this.setPrivate("scaleY", 1);
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("layoutAlgorithm")) {
      let algorithm;
      switch (this.get("layoutAlgorithm")) {
        case "squarify":
          algorithm = squarify_default;
          break;
        case "binary":
          algorithm = binary_default;
          break;
        case "slice":
          algorithm = slice_default;
          break;
        case "dice":
          algorithm = dice_default;
          break;
        case "sliceDice":
          algorithm = sliceDice_default;
          break;
      }
      if (algorithm) {
        this._treemapLayout = treemap_default().tile(algorithm);
      }
      if (this._rootNode) {
        this._updateNodes(this._rootNode);
      }
    }
    if (this.isDirty("nodePaddingRight") || this.isDirty("nodePaddingLeft") || this.isDirty("nodePaddingTop") || this.isDirty("nodePaddingBottom") || this.isDirty("nodePaddingOuter") || this.isDirty("nodePaddingInner")) {
      if (this._rootNode) {
        this._updateNodes(this._rootNode);
      }
    }
    if (this.isPrivateDirty("scaleX") || this.isPrivateDirty("scaleY")) {
      if (this._rootNode) {
        this._updateNodesScale(this._rootNode);
      }
    }
  }
  _updateVisuals() {
    if (this._rootNode) {
      const treemapLayout = this._treemapLayout;
      treemapLayout.size([this.innerWidth(), this.innerHeight()]);
      const paddingLeft = this.get("nodePaddingLeft");
      const paddingRight = this.get("nodePaddingRight");
      const paddingTop = this.get("nodePaddingTop");
      const paddingBottom = this.get("nodePaddingBottom");
      const paddingInner = this.get("nodePaddingInner");
      const paddingOuter = this.get("nodePaddingOuter");
      if (isNumber(paddingLeft)) {
        treemapLayout.paddingLeft(paddingLeft);
      }
      if (isNumber(paddingRight)) {
        treemapLayout.paddingRight(paddingRight);
      }
      if (isNumber(paddingTop)) {
        treemapLayout.paddingTop(paddingTop);
      }
      if (isNumber(paddingBottom)) {
        treemapLayout.paddingBottom(paddingBottom);
      }
      if (isNumber(paddingInner)) {
        treemapLayout.paddingInner(paddingInner);
      }
      if (isNumber(paddingOuter)) {
        treemapLayout.paddingOuter(paddingOuter);
      }
      treemapLayout(this._rootNode);
      this._updateNodes(this._rootNode);
    }
  }
  _updateNode(dataItem) {
    super._updateNode(dataItem);
    const node = dataItem.get("node");
    const rectangle = dataItem.get("rectangle");
    const hierarchyNode = dataItem.get("d3HierarchyNode");
    const scaleX = this.getPrivate("scaleX", 1);
    const scaleY = this.getPrivate("scaleY", 1);
    const x0 = hierarchyNode.x0 * scaleX;
    const x1 = hierarchyNode.x1 * scaleX;
    const y0 = hierarchyNode.y0 * scaleY;
    const y1 = hierarchyNode.y1 * scaleY;
    const w = x1 - x0;
    const h = y1 - y0;
    const duration = this.get("animationDuration", 0);
    const easing = this.get("animationEasing");
    node.animate({ key: "x", to: x0, duration, easing });
    node.animate({ key: "y", to: y0, duration, easing });
    node.animate({ key: "width", to: w, duration, easing });
    node.animate({ key: "height", to: h, duration, easing });
    if (rectangle) {
      const fill = dataItem.get("fill");
      rectangle.animate({ key: "width", to: w, duration, easing });
      rectangle.animate({ key: "height", to: h, duration, easing });
      rectangle._setDefault("fill", fill);
      rectangle._setDefault("stroke", fill);
    }
  }
  _updateNodesScale(hierarchyNode) {
    const dataItem = hierarchyNode.data.dataItem;
    if (dataItem) {
      const node = dataItem.get("node");
      const rectangle = dataItem.get("rectangle");
      const scaleX = this.getPrivate("scaleX", 1);
      const scaleY = this.getPrivate("scaleY", 1);
      const x0 = hierarchyNode.x0 * scaleX;
      const x1 = hierarchyNode.x1 * scaleX;
      const y0 = hierarchyNode.y0 * scaleY;
      const y1 = hierarchyNode.y1 * scaleY;
      const w = x1 - x0;
      const h = y1 - y0;
      node.setAll({ x: x0, y: y0, width: w, height: h });
      rectangle.setAll({ width: w, height: h });
      const hierarchyChildren = hierarchyNode.children;
      if (hierarchyChildren) {
        each(hierarchyChildren, (hierarchyChild) => {
          this._updateNodesScale(hierarchyChild);
        });
      }
    }
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const node = super.makeNode(dataItem);
    const rectangle = node.children.moveValue(this.rectangles.make(), 0);
    node.setPrivate("tooltipTarget", rectangle);
    dataItem.setRaw("rectangle", rectangle);
    const label = dataItem.get("label");
    rectangle.on("width", () => {
      label.setPrivate("maxWidth", rectangle.width());
    });
    rectangle.on("height", () => {
      label.setPrivate("maxHeight", rectangle.height());
    });
    return node;
  }
  _zoom(dataItem) {
    if (this.width() > 0 && this.height() > 0) {
      const hierarchyNode = dataItem.get("d3HierarchyNode");
      const nodePaddingOuter = this.get("nodePaddingOuter", 0);
      let x0 = hierarchyNode.x0 + nodePaddingOuter;
      let x1 = hierarchyNode.x1 - nodePaddingOuter;
      let y0 = hierarchyNode.y0 + nodePaddingOuter;
      let y1 = hierarchyNode.y1 - nodePaddingOuter;
      let scaleX = (this.innerWidth() - nodePaddingOuter * 2) / (x1 - x0);
      let scaleY = (this.innerHeight() - nodePaddingOuter * 2) / (y1 - y0);
      const easing = this.get("animationEasing");
      let duration = this.get("animationDuration", 0);
      if (!this.inited) {
        duration = 0;
      }
      this.animatePrivate({ key: "scaleX", to: scaleX, duration, easing });
      this.animatePrivate({ key: "scaleY", to: scaleY, duration, easing });
      this.nodesContainer.animate({ key: "x", to: nodePaddingOuter - x0 * scaleX, duration, easing });
      this.nodesContainer.animate({ key: "y", to: nodePaddingOuter - y0 * scaleY, duration, easing });
    }
  }
  _selectDataItem(dataItem, downDepth, skipDisptach) {
    super._selectDataItem(dataItem, downDepth, skipDisptach);
    if (dataItem) {
      let maxDepth = this.get("downDepth", 1) + dataItem.get("depth");
      if (!this.inited) {
        maxDepth = this.get("initialDepth", 1);
      }
      const visibleNodes = this._getVisibleNodes(dataItem, maxDepth);
      this.nodes.each((node) => {
        if (visibleNodes.indexOf(node.dataItem) == -1) {
          node.setPrivate("focusable", false);
        } else {
          node.removePrivate("focusable");
        }
      });
    }
    this._root._invalidateTabindexes();
  }
  _getVisibleNodes(dataItem, maxDepth) {
    const children = dataItem.get("children");
    let includedChildren = [];
    each(children, (child) => {
      if (child.get("depth") == maxDepth || !child.get("children")) {
        includedChildren.push(child);
      } else {
        includedChildren = includedChildren.concat(this._getVisibleNodes(child, maxDepth));
      }
    });
    return includedChildren;
  }
};
Object.defineProperty(Treemap, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Treemap"
});
Object.defineProperty(Treemap, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Hierarchy.classNames.concat([Treemap.className])
});

// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/area.js
function area_default(polygon) {
  var i = -1, n = polygon.length, a3, b = polygon[n - 1], area = 0;
  while (++i < n) {
    a3 = b;
    b = polygon[i];
    area += a3[1] * b[0] - a3[0] * b[1];
  }
  return area / 2;
}

// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/centroid.js
function centroid_default(polygon) {
  var i = -1, n = polygon.length, x3 = 0, y3 = 0, a3, b = polygon[n - 1], c3, k = 0;
  while (++i < n) {
    a3 = b;
    b = polygon[i];
    k += c3 = a3[0] * b[1] - b[0] * a3[1];
    x3 += (a3[0] + b[0]) * c3;
    y3 += (a3[1] + b[1]) * c3;
  }
  return k *= 3, [x3 / k, y3 / k];
}

// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/contains.js
function contains_default(polygon, point) {
  var n = polygon.length, p = polygon[n - 1], x3 = point[0], y3 = point[1], x0 = p[0], y0 = p[1], x1, y1, inside = false;
  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y3 !== y0 > y3 && x3 < (x0 - x1) * (y3 - y1) / (y0 - y1) + x1)
      inside = !inside;
    x0 = x1, y0 = y1;
  }
  return inside;
}

// node_modules/d3-voronoi-map/node_modules/d3-timer/src/timer.js
var frame2 = 0;
var timeout2 = 0;
var interval2 = 0;
var pokeDelay2 = 1e3;
var taskHead2;
var taskTail2;
var clockLast2 = 0;
var clockNow2 = 0;
var clockSkew2 = 0;
var clock2 = typeof performance === "object" && performance.now ? performance : Date;
var setFrame2 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now2() {
  return clockNow2 || (setFrame2(clearNow2), clockNow2 = clock2.now() + clockSkew2);
}
function clearNow2() {
  clockNow2 = 0;
}
function Timer2() {
  this._call = this._time = this._next = null;
}
Timer2.prototype = timer2.prototype = {
  constructor: Timer2,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now2() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail2 !== this) {
      if (taskTail2)
        taskTail2._next = this;
      else
        taskHead2 = this;
      taskTail2 = this;
    }
    this._call = callback;
    this._time = time;
    sleep2();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep2();
    }
  }
};
function timer2(callback, delay, time) {
  var t = new Timer2();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush2() {
  now2();
  ++frame2;
  var t = taskHead2, e;
  while (t) {
    if ((e = clockNow2 - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame2;
}
function wake2() {
  clockNow2 = (clockLast2 = clock2.now()) + clockSkew2;
  frame2 = timeout2 = 0;
  try {
    timerFlush2();
  } finally {
    frame2 = 0;
    nap2();
    clockNow2 = 0;
  }
}
function poke2() {
  var now3 = clock2.now(), delay = now3 - clockLast2;
  if (delay > pokeDelay2)
    clockSkew2 -= delay, clockLast2 = now3;
}
function nap2() {
  var t0, t1 = taskHead2, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead2 = t2;
    }
  }
  taskTail2 = t0;
  sleep2(time);
}
function sleep2(time) {
  if (frame2)
    return;
  if (timeout2)
    timeout2 = clearTimeout(timeout2);
  var delay = time - clockNow2;
  if (delay > 24) {
    if (time < Infinity)
      timeout2 = setTimeout(wake2, time - clock2.now() - clockSkew2);
    if (interval2)
      interval2 = clearInterval(interval2);
  } else {
    if (!interval2)
      clockLast2 = clock2.now(), interval2 = setInterval(poke2, pokeDelay2);
    frame2 = 1, setFrame2(wake2);
  }
}

// node_modules/d3-voronoi-map/node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch2() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch2(_);
}
function Dispatch2(_) {
  this._ = _;
}
function parseTypenames2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch2.prototype = dispatch2.prototype = {
  constructor: Dispatch2,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames2(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get2(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set2(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch2(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get2(type, name) {
  for (var i = 0, n = type.length, c3; i < n; ++i) {
    if ((c3 = type[i]).name === name) {
      return c3.value;
    }
  }
}
function set2(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var dispatch_default2 = dispatch2;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/ascending.js
function ascending_default(a3, b) {
  return a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x3) => f(d) - x3;
    compare = ascendingComparator(f);
  }
  function left(a3, x3, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a3[mid], x3) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a3, x3, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a3[mid], x3) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a3, x3, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    const i = left(a3, x3, lo, hi - 1);
    return i > lo && delta(a3[i - 1], x3) > -delta(a3[i], x3) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x3) => ascending_default(f(d), x3);
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/number.js
function number_default(x3) {
  return x3 === null ? NaN : +x3;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/extent.js
function extent_default2(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random() * m3-- | 0, t = array2[m3 + i0];
      array2[m3 + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/cross.js
function cross_default2(a3, b, c3) {
  return (b[0] - a3[0]) * (c3[1] - a3[1]) - (b[1] - a3[1]) * (c3[0] - a3[0]);
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/hull.js
function lexicographicOrder(a3, b) {
  return a3[0] - b[0] || a3[1] - b[1];
}
function computeUpperHullIndexes(points) {
  const n = points.length, indexes2 = [0, 1];
  let size = 2, i;
  for (i = 2; i < n; ++i) {
    while (size > 1 && cross_default2(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)
      --size;
    indexes2[size++] = i;
  }
  return indexes2.slice(0, size);
}
function hull_default2(points) {
  if ((n = points.length) < 3)
    return null;
  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i = 0; i < n; ++i)
    sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i)
    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
  for (i = upperIndexes.length - 1; i >= 0; --i)
    hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
    hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
  return hull;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/length.js
function length_default2(polygon) {
  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.hypot(xa, ya);
  }
  return perimeter;
}

// node_modules/d3-weighted-voronoi/src/utils.js
var epsilon = 1e-10;
function epsilonesque(n) {
  return n <= epsilon && n >= -epsilon;
}
function dot(v0, v1) {
  return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
}
function linearDependent(v0, v1) {
  return epsilonesque(v0.x * v1.y - v0.y * v1.x) && epsilonesque(v0.y * v1.z - v0.z * v1.y) && epsilonesque(v0.z * v1.x - v0.x * v1.z);
}
function polygonDirection(polygon) {
  var sign, crossproduct, p0, p1, p2, v0, v1, i;
  p0 = polygon[polygon.length - 2];
  p1 = polygon[polygon.length - 1];
  p2 = polygon[0];
  v0 = vect(p0, p1);
  v1 = vect(p1, p2);
  crossproduct = calculateCrossproduct(v0, v1);
  sign = Math.sign(crossproduct);
  p0 = p1;
  p1 = p2;
  p2 = polygon[1];
  v0 = v1;
  v1 = vect(p1, p2);
  crossproduct = calculateCrossproduct(v0, v1);
  if (Math.sign(crossproduct) !== sign) {
    return void 0;
  }
  for (i = 2; i < polygon.length - 1; i++) {
    p0 = p1;
    p1 = p2;
    p2 = polygon[i];
    v0 = v1;
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    if (Math.sign(crossproduct) !== sign) {
      return void 0;
    }
  }
  return sign;
}
function vect(from, to) {
  return [to[0] - from[0], to[1] - from[1]];
}
function calculateCrossproduct(v0, v1) {
  return v0[0] * v1[1] - v0[1] * v1[0];
}

// node_modules/d3-weighted-voronoi/src/conflictList.js
function ConflictListNode(face, vert) {
  this.face = face;
  this.vert = vert;
  this.nextf = null;
  this.prevf = null;
  this.nextv = null;
  this.prevv = null;
}
function ConflictList(forFace) {
  this.forFace = forFace;
  this.head = null;
}
ConflictList.prototype.add = function(cln) {
  if (this.head === null) {
    this.head = cln;
  } else {
    if (this.forFace) {
      this.head.prevv = cln;
      cln.nextv = this.head;
      this.head = cln;
    } else {
      this.head.prevf = cln;
      cln.nextf = this.head;
      this.head = cln;
    }
  }
};
ConflictList.prototype.isEmpty = function() {
  return this.head === null;
};
ConflictList.prototype.fill = function(visible) {
  if (this.forFace) {
    return;
  }
  var curr = this.head;
  do {
    visible.push(curr.face);
    curr.face.marked = true;
    curr = curr.nextf;
  } while (curr !== null);
};
ConflictList.prototype.removeAll = function() {
  if (this.forFace) {
    var curr = this.head;
    do {
      if (curr.prevf === null) {
        if (curr.nextf === null) {
          curr.vert.conflicts.head = null;
        } else {
          curr.nextf.prevf = null;
          curr.vert.conflicts.head = curr.nextf;
        }
      } else {
        if (curr.nextf != null) {
          curr.nextf.prevf = curr.prevf;
        }
        curr.prevf.nextf = curr.nextf;
      }
      curr = curr.nextv;
      if (curr != null) {
        curr.prevv = null;
      }
    } while (curr != null);
  } else {
    var curr = this.head;
    do {
      if (curr.prevv == null) {
        if (curr.nextv == null) {
          curr.face.conflicts.head = null;
        } else {
          curr.nextv.prevv = null;
          curr.face.conflicts.head = curr.nextv;
        }
      } else {
        if (curr.nextv != null) {
          curr.nextv.prevv = curr.prevv;
        }
        curr.prevv.nextv = curr.nextv;
      }
      curr = curr.nextf;
      if (curr != null)
        curr.prevf = null;
    } while (curr != null);
  }
};
ConflictList.prototype.getVertices = function() {
  var list = [], curr = this.head;
  while (curr !== null) {
    list.push(curr.vert);
    curr = curr.nextv;
  }
  return list;
};

// node_modules/d3-weighted-voronoi/src/vertex.js
function Vertex(x3, y3, z, weight, orig, isDummy) {
  this.x = x3;
  this.y = y3;
  this.weight = epsilon;
  this.index = 0;
  this.conflicts = new ConflictList(false);
  this.neighbours = null;
  this.nonClippedPolygon = null;
  this.polygon = null;
  this.originalObject = null;
  this.isDummy = false;
  if (orig !== void 0) {
    this.originalObject = orig;
  }
  if (isDummy != void 0) {
    this.isDummy = isDummy;
  }
  if (weight != null) {
    this.weight = weight;
  }
  if (z != null) {
    this.z = z;
  } else {
    this.z = this.projectZ(this.x, this.y, this.weight);
  }
}
Vertex.prototype.projectZ = function(x3, y3, weight) {
  return x3 * x3 + y3 * y3 - weight;
};
Vertex.prototype.setWeight = function(weight) {
  this.weight = weight;
  this.z = this.projectZ(this.x, this.y, this.weight);
};
Vertex.prototype.subtract = function(v) {
  return new Vertex(v.x - this.x, v.y - this.y, v.z - this.z);
};
Vertex.prototype.crossproduct = function(v) {
  return new Vertex(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
};
Vertex.prototype.equals = function(v) {
  return this.x === v.x && this.y === v.y && this.z === v.z;
};

// node_modules/d3-weighted-voronoi/src/plane3D.js
function Plane3D(face) {
  var p1 = face.verts[0];
  var p2 = face.verts[1];
  var p3 = face.verts[2];
  this.a = p1.y * (p2.z - p3.z) + p2.y * (p3.z - p1.z) + p3.y * (p1.z - p2.z);
  this.b = p1.z * (p2.x - p3.x) + p2.z * (p3.x - p1.x) + p3.z * (p1.x - p2.x);
  this.c = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
  this.d = -1 * (p1.x * (p2.y * p3.z - p3.y * p2.z) + p2.x * (p3.y * p1.z - p1.y * p3.z) + p3.x * (p1.y * p2.z - p2.y * p1.z));
}
Plane3D.prototype.getNormZPlane = function() {
  return [
    -1 * (this.a / this.c),
    -1 * (this.b / this.c),
    -1 * (this.d / this.c)
  ];
};
Plane3D.prototype.getDualPointMappedToPlane = function() {
  var nplane = this.getNormZPlane();
  var dualPoint = new Point2D(nplane[0] / 2, nplane[1] / 2);
  return dualPoint;
};
function Point2D(x3, y3) {
  this.x = x3;
  this.y = y3;
}

// node_modules/d3-weighted-voronoi/src/vector.js
function Vector(x3, y3, z) {
  this.x = x3;
  this.y = y3;
  this.z = z;
}
Vector.prototype.negate = function() {
  this.x *= -1;
  this.y *= -1;
  this.z *= -1;
};
Vector.prototype.normalize = function() {
  var lenght = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  if (lenght > 0) {
    this.x /= lenght;
    this.y /= lenght;
    this.z /= lenght;
  }
};

// node_modules/d3-weighted-voronoi/src/hEdge.js
function HEdge(orig, dest, face) {
  this.next = null;
  this.prev = null;
  this.twin = null;
  this.orig = orig;
  this.dest = dest;
  this.iFace = face;
}
HEdge.prototype.isHorizon = function() {
  return this.twin !== null && !this.iFace.marked && this.twin.iFace.marked;
};
HEdge.prototype.findHorizon = function(horizon) {
  if (this.isHorizon()) {
    if (horizon.length > 0 && this === horizon[0]) {
      return;
    } else {
      horizon.push(this);
      this.next.findHorizon(horizon);
    }
  } else {
    if (this.twin !== null) {
      this.twin.next.findHorizon(horizon);
    }
  }
};
HEdge.prototype.isEqual = function(origin, dest) {
  return this.orig.equals(origin) && this.dest.equals(dest) || this.orig.equals(dest) && this.dest.equals(origin);
};

// node_modules/d3-weighted-voronoi/src/d3-weighted-voronoi-error.js
function d3WeightedVoronoiError(message) {
  this.message = message;
  this.stack = new Error().stack;
}
d3WeightedVoronoiError.prototype.name = "d3WeightedVoronoiError";
d3WeightedVoronoiError.prototype = new Error();

// node_modules/d3-weighted-voronoi/src/face.js
function Face(a3, b, c3, orient) {
  this.conflicts = new ConflictList(true);
  this.verts = [a3, b, c3];
  this.marked = false;
  var t = a3.subtract(b).crossproduct(b.subtract(c3));
  this.normal = new Vector(-t.x, -t.y, -t.z);
  this.normal.normalize();
  this.createEdges();
  this.dualPoint = null;
  if (orient != void 0) {
    this.orient(orient);
  }
}
Face.prototype.getDualPoint = function() {
  if (this.dualPoint == null) {
    var plane3d = new Plane3D(this);
    this.dualPoint = plane3d.getDualPointMappedToPlane();
  }
  return this.dualPoint;
};
Face.prototype.isVisibleFromBelow = function() {
  return this.normal.z < -14259414393190911e-25;
};
Face.prototype.createEdges = function() {
  this.edges = [];
  this.edges[0] = new HEdge(this.verts[0], this.verts[1], this);
  this.edges[1] = new HEdge(this.verts[1], this.verts[2], this);
  this.edges[2] = new HEdge(this.verts[2], this.verts[0], this);
  this.edges[0].next = this.edges[1];
  this.edges[0].prev = this.edges[2];
  this.edges[1].next = this.edges[2];
  this.edges[1].prev = this.edges[0];
  this.edges[2].next = this.edges[0];
  this.edges[2].prev = this.edges[1];
};
Face.prototype.orient = function(orient) {
  if (!(dot(this.normal, orient) < dot(this.normal, this.verts[0]))) {
    var temp = this.verts[1];
    this.verts[1] = this.verts[2];
    this.verts[2] = temp;
    this.normal.negate();
    this.createEdges();
  }
};
Face.prototype.getEdge = function(v0, v1) {
  for (var i = 0; i < 3; i++) {
    if (this.edges[i].isEqual(v0, v1)) {
      return this.edges[i];
    }
  }
  return null;
};
Face.prototype.link = function(face, v0, v1) {
  if (face instanceof Face) {
    var twin = face.getEdge(v0, v1);
    if (twin === null) {
      throw new d3WeightedVoronoiError("when linking, twin is null");
    }
    var edge = this.getEdge(v0, v1);
    if (edge === null) {
      throw new d3WeightedVoronoiError("when linking, twin is null");
    }
    twin.twin = edge;
    edge.twin = twin;
  } else {
    var twin = face;
    var edge = this.getEdge(twin.orig, twin.dest);
    twin.twin = edge;
    edge.twin = twin;
  }
};
Face.prototype.conflict = function(v) {
  return dot(this.normal, v) > dot(this.normal, this.verts[0]) + epsilon;
};
Face.prototype.getHorizon = function() {
  for (var i = 0; i < 3; i++) {
    if (this.edges[i].twin !== null && this.edges[i].twin.isHorizon()) {
      return this.edges[i];
    }
  }
  return null;
};
Face.prototype.removeConflict = function() {
  this.conflicts.removeAll();
};

// node_modules/d3-weighted-voronoi/src/convexHull.js
function ConvexHull() {
  this.points = [];
  this.facets = [];
  this.created = [];
  this.horizon = [];
  this.visible = [];
  this.current = 0;
}
ConvexHull.prototype.init = function(boundingSites, sites) {
  this.points = [];
  for (var i = 0; i < sites.length; i++) {
    this.points[i] = new Vertex(sites[i].x, sites[i].y, sites[i].z, null, sites[i], false);
  }
  this.points = this.points.concat(boundingSites);
};
ConvexHull.prototype.permutate = function() {
  var pointSize = this.points.length;
  for (var i = pointSize - 1; i > 0; i--) {
    var ra = Math.floor(Math.random() * i);
    var temp = this.points[ra];
    temp.index = i;
    var currentItem = this.points[i];
    currentItem.index = ra;
    this.points.splice(ra, 1, currentItem);
    this.points.splice(i, 1, temp);
  }
};
ConvexHull.prototype.prep = function() {
  if (this.points.length <= 3) {
    throw new d3WeightedVoronoiError("Less than 4 points");
  }
  for (var i = 0; i < this.points.length; i++) {
    this.points[i].index = i;
  }
  var v0, v1, v2, v3;
  var f1, f2, f3, f0;
  v0 = this.points[0];
  v1 = this.points[1];
  v2 = v3 = null;
  for (var i = 2; i < this.points.length; i++) {
    if (!(linearDependent(v0, this.points[i]) && linearDependent(v1, this.points[i]))) {
      v2 = this.points[i];
      v2.index = 2;
      this.points[2].index = i;
      this.points.splice(i, 1, this.points[2]);
      this.points.splice(2, 1, v2);
      break;
    }
  }
  if (v2 === null) {
    throw new d3WeightedVoronoiError("Not enough non-planar Points (v2 is null)");
  }
  f0 = new Face(v0, v1, v2);
  for (var i = 3; i < this.points.length; i++) {
    if (!epsilonesque(dot(f0.normal, f0.verts[0]) - dot(f0.normal, this.points[i]))) {
      v3 = this.points[i];
      v3.index = 3;
      this.points[3].index = i;
      this.points.splice(i, 1, this.points[3]);
      this.points.splice(3, 1, v3);
      break;
    }
  }
  if (v3 === null) {
    throw new d3WeightedVoronoiError("Not enough non-planar Points (v3 is null)");
  }
  f0.orient(v3);
  f1 = new Face(v0, v2, v3, v1);
  f2 = new Face(v0, v1, v3, v2);
  f3 = new Face(v1, v2, v3, v0);
  this.addFacet(f0);
  this.addFacet(f1);
  this.addFacet(f2);
  this.addFacet(f3);
  f0.link(f1, v0, v2);
  f0.link(f2, v0, v1);
  f0.link(f3, v1, v2);
  f1.link(f2, v0, v3);
  f1.link(f3, v2, v3);
  f2.link(f3, v3, v1);
  this.current = 4;
  var v;
  for (var i = this.current; i < this.points.length; i++) {
    v = this.points[i];
    if (f0.conflict(v)) {
      this.addConflict(f0, v);
    }
    if (f1.conflict(v)) {
      this.addConflict(f1, v);
    }
    if (f2.conflict(v)) {
      this.addConflict(f2, v);
    }
    if (f3.conflict(v)) {
      this.addConflict(f3, v);
    }
  }
}, // IN: Faces old1 old2 and fn
ConvexHull.prototype.addConflicts = function(old1, old2, fn) {
  var l1 = old1.conflicts.getVertices();
  var l2 = old2.conflicts.getVertices();
  var nCL = [];
  var v1, v2;
  var i, l;
  i = l = 0;
  while (i < l1.length || l < l2.length) {
    if (i < l1.length && l < l2.length) {
      v1 = l1[i];
      v2 = l2[l];
      if (v1.index === v2.index) {
        nCL.push(v1);
        i++;
        l++;
      } else if (v1.index > v2.index) {
        nCL.push(v1);
        i++;
      } else {
        nCL.push(v2);
        l++;
      }
    } else if (i < l1.length) {
      nCL.push(l1[i++]);
    } else {
      nCL.push(l2[l++]);
    }
  }
  for (var i = nCL.length - 1; i >= 0; i--) {
    v1 = nCL[i];
    if (fn.conflict(v1))
      this.addConflict(fn, v1);
  }
};
ConvexHull.prototype.addConflict = function(face, vert) {
  var e = new ConflictListNode(face, vert);
  face.conflicts.add(e);
  vert.conflicts.add(e);
};
ConvexHull.prototype.removeConflict = function(f) {
  f.removeConflict();
  var index3 = f.index;
  f.index = -1;
  if (index3 === this.facets.length - 1) {
    this.facets.splice(this.facets.length - 1, 1);
    return;
  }
  if (index3 >= this.facets.length || index3 < 0)
    return;
  var last = this.facets.splice(this.facets.length - 1, 1);
  last[0].index = index3;
  this.facets.splice(index3, 1, last[0]);
};
ConvexHull.prototype.addFacet = function(face) {
  face.index = this.facets.length;
  this.facets.push(face);
};
ConvexHull.prototype.compute = function() {
  this.prep();
  while (this.current < this.points.length) {
    var next = this.points[this.current];
    if (next.conflicts.isEmpty()) {
      this.current++;
      continue;
    }
    this.created = [];
    this.horizon = [];
    this.visible = [];
    next.conflicts.fill(this.visible);
    var e;
    for (var jF = 0; jF < this.visible.length; jF++) {
      e = this.visible[jF].getHorizon();
      if (e !== null) {
        e.findHorizon(this.horizon);
        break;
      }
    }
    var last = null, first = null;
    for (var hEi = 0; hEi < this.horizon.length; hEi++) {
      var hE = this.horizon[hEi];
      var fn = new Face(next, hE.orig, hE.dest, hE.twin.next.dest);
      fn.conflicts = new ConflictList(true);
      this.addFacet(fn);
      this.created.push(fn);
      this.addConflicts(hE.iFace, hE.twin.iFace, fn);
      fn.link(hE);
      if (last !== null)
        fn.link(last, next, hE.orig);
      last = fn;
      if (first === null)
        first = fn;
    }
    if (first !== null && last !== null) {
      last.link(first, next, this.horizon[0].orig);
    }
    if (this.created.length != 0) {
      for (var f = 0; f < this.visible.length; f++) {
        this.removeConflict(this.visible[f]);
      }
      this.current++;
      this.created = [];
    }
  }
  return this.facets;
};
ConvexHull.prototype.clear = function() {
  this.points = [];
  this.facets = [];
  this.created = [];
  this.horizon = [];
  this.visible = [];
  this.current = 0;
};

// node_modules/d3-weighted-voronoi/src/d3-polygon-clip.js
function polygonClip(clip, subject) {
  var input, closed = polygonClosed(subject), i = -1, n = clip.length - polygonClosed(clip), j, m3, a3 = clip[n - 1], b, c3, d, intersection2;
  while (++i < n) {
    input = subject.slice();
    subject.length = 0;
    b = clip[i];
    c3 = input[(m3 = input.length - closed) - 1];
    j = -1;
    while (++j < m3) {
      d = input[j];
      if (polygonInside(d, a3, b)) {
        if (!polygonInside(c3, a3, b)) {
          intersection2 = polygonIntersect(c3, d, a3, b);
          if (isFinite(intersection2[0])) {
            subject.push(intersection2);
          }
        }
        subject.push(d);
      } else if (polygonInside(c3, a3, b)) {
        intersection2 = polygonIntersect(c3, d, a3, b);
        if (isFinite(intersection2[0])) {
          subject.push(intersection2);
        }
      }
      c3 = d;
    }
    if (closed)
      subject.push(subject[0]);
    a3 = b;
  }
  return subject;
}
function polygonInside(p, a3, b) {
  return (b[0] - a3[0]) * (p[1] - a3[1]) < (b[1] - a3[1]) * (p[0] - a3[0]);
}
function polygonIntersect(c3, d, a3, b) {
  var x1 = c3[0], x3 = a3[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c3[1], y3 = a3[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
  return [x1 + ua * x21, y1 + ua * y21];
}
function polygonClosed(coordinates) {
  var a3 = coordinates[0], b = coordinates[coordinates.length - 1];
  return !(a3[0] - b[0] || a3[1] - b[1]);
}

// node_modules/d3-weighted-voronoi/src/powerDiagram.js
function getFacesOfDestVertex(edge) {
  var faces = [];
  var previous = edge;
  var first = edge.dest;
  var site = first.originalObject;
  var neighbours = [];
  do {
    previous = previous.twin.prev;
    var siteOrigin = previous.orig.originalObject;
    if (!siteOrigin.isDummy) {
      neighbours.push(siteOrigin);
    }
    var iFace = previous.iFace;
    if (iFace.isVisibleFromBelow()) {
      faces.push(iFace);
    }
  } while (previous !== edge);
  site.neighbours = neighbours;
  return faces;
}
function computePowerDiagramIntegrated(sites, boundingSites, clippingPolygon) {
  var convexHull = new ConvexHull();
  convexHull.clear();
  convexHull.init(boundingSites, sites);
  var facets = convexHull.compute(sites);
  var polygons = [];
  var verticesVisited = [];
  var facetCount = facets.length;
  for (var i = 0; i < facetCount; i++) {
    var facet = facets[i];
    if (facet.isVisibleFromBelow()) {
      for (var e = 0; e < 3; e++) {
        var edge = facet.edges[e];
        var destVertex = edge.dest;
        var site = destVertex.originalObject;
        if (!verticesVisited[destVertex.index]) {
          verticesVisited[destVertex.index] = true;
          if (site.isDummy) {
            continue;
          }
          var faces = getFacesOfDestVertex(edge);
          var protopoly = [];
          var lastX = null;
          var lastY = null;
          var dx = 1;
          var dy = 1;
          for (var j = 0; j < faces.length; j++) {
            var point = faces[j].getDualPoint();
            var x1 = point.x;
            var y1 = point.y;
            if (lastX !== null) {
              dx = lastX - x1;
              dy = lastY - y1;
              if (dx < 0) {
                dx = -dx;
              }
              if (dy < 0) {
                dy = -dy;
              }
            }
            if (dx > epsilon || dy > epsilon) {
              protopoly.push([x1, y1]);
              lastX = x1;
              lastY = y1;
            }
          }
          site.nonClippedPolygon = protopoly.reverse();
          if (!site.isDummy && length_default2(site.nonClippedPolygon) > 0) {
            var clippedPoly = polygonClip(clippingPolygon, site.nonClippedPolygon);
            site.polygon = clippedPoly;
            clippedPoly.site = site;
            if (clippedPoly.length > 0) {
              polygons.push(clippedPoly);
            }
          }
        }
      }
    }
  }
  return polygons;
}

// node_modules/d3-weighted-voronoi/src/d3-weighted-voronoi.js
function weightedVoronoi() {
  var x3 = function(d) {
    return d.x;
  };
  var y3 = function(d) {
    return d.y;
  };
  var weight = function(d) {
    return d.weight;
  };
  var clip = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
  var extent = [
    [0, 0],
    [1, 1]
  ];
  var size = [1, 1];
  function _weightedVoronoi(data) {
    var formatedSites;
    formatedSites = data.map(function(d) {
      return new Vertex(x3(d), y3(d), null, weight(d), d, false);
    });
    return computePowerDiagramIntegrated(formatedSites, boundingSites(), clip);
  }
  _weightedVoronoi.x = function(_) {
    if (!arguments.length) {
      return x3;
    }
    x3 = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.y = function(_) {
    if (!arguments.length) {
      return y3;
    }
    y3 = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.weight = function(_) {
    if (!arguments.length) {
      return weight;
    }
    weight = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.clip = function(_) {
    var direction2, xExtent, yExtent;
    if (!arguments.length) {
      return clip;
    }
    xExtent = extent_default2(
      _.map(function(c3) {
        return c3[0];
      })
    );
    yExtent = extent_default2(
      _.map(function(c3) {
        return c3[1];
      })
    );
    direction2 = polygonDirection(_);
    if (direction2 === void 0) {
      clip = hull_default2(_);
    } else if (direction2 === 1) {
      clip = _.reverse();
    } else {
      clip = _;
    }
    extent = [
      [xExtent[0], yExtent[0]],
      [xExtent[1], yExtent[1]]
    ];
    size = [xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]];
    return _weightedVoronoi;
  };
  _weightedVoronoi.extent = function(_) {
    if (!arguments.length) {
      return extent;
    }
    clip = [_[0], [_[0][0], _[1][1]], _[1], [_[1][0], _[0][1]]];
    extent = _;
    size = [_[1][0] - _[0][0], _[1][1] - _[0][1]];
    return _weightedVoronoi;
  };
  _weightedVoronoi.size = function(_) {
    if (!arguments.length) {
      return size;
    }
    clip = [
      [0, 0],
      [0, _[1]],
      [_[0], _[1]],
      [_[0], 0]
    ];
    extent = [[0, 0], _];
    size = _;
    return _weightedVoronoi;
  };
  function boundingSites() {
    var minX, maxX, minY, maxY, width, height, x0, x1, y0, y1, boundingData = [], boundingSites2 = [];
    minX = extent[0][0];
    maxX = extent[1][0];
    minY = extent[0][1];
    maxY = extent[1][1];
    width = maxX - minX;
    height = maxY - minY;
    x0 = minX - width;
    x1 = maxX + width;
    y0 = minY - height;
    y1 = maxY + height;
    boundingData[0] = [x0, y0];
    boundingData[1] = [x0, y1];
    boundingData[2] = [x1, y1];
    boundingData[3] = [x1, y0];
    for (var i = 0; i < 4; i++) {
      boundingSites2.push(
        new Vertex(
          boundingData[i][0],
          boundingData[i][1],
          null,
          epsilon,
          new Vertex(boundingData[i][0], boundingData[i][1], null, epsilon, null, true),
          true
        )
      );
    }
    return boundingSites2;
  }
  return _weightedVoronoi;
}

// node_modules/d3-voronoi-map/src/flickering-mitigation.js
function FlickeringMitigation() {
  this.growthChangesLength = DEFAULT_LENGTH;
  this.totalAvailableArea = NaN;
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
}
var DEFAULT_LENGTH = 10;
function direction(h0, h1) {
  return h0 >= h1 ? 1 : -1;
}
function generateGrowthChangeWeights(length) {
  var initialWeight = 3;
  var weightDecrement = 1;
  var minWeight = 1;
  var weightedCount = initialWeight;
  var growthChangeWeights = [];
  for (var i = 0; i < length; i++) {
    growthChangeWeights.push(weightedCount);
    weightedCount -= weightDecrement;
    if (weightedCount < minWeight) {
      weightedCount = minWeight;
    }
  }
  return growthChangeWeights;
}
function computeGrowthChangeWeightsSum(growthChangeWeights) {
  var growthChangeWeightsSum = 0;
  for (var i = 0; i < growthChangeWeights.length; i++) {
    growthChangeWeightsSum += growthChangeWeights[i];
  }
  return growthChangeWeightsSum;
}
FlickeringMitigation.prototype.reset = function() {
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  this.growthChangesLength = DEFAULT_LENGTH;
  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  this.totalAvailableArea = NaN;
  return this;
};
FlickeringMitigation.prototype.clear = function() {
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  return this;
};
FlickeringMitigation.prototype.length = function(_) {
  if (!arguments.length) {
    return this.growthChangesLength;
  }
  if (parseInt(_) > 0) {
    this.growthChangesLength = Math.floor(parseInt(_));
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  } else {
    console.warn("FlickeringMitigation.length() accepts only positive integers; unable to handle " + _);
  }
  return this;
};
FlickeringMitigation.prototype.totalArea = function(_) {
  if (!arguments.length) {
    return this.totalAvailableArea;
  }
  if (parseFloat(_) > 0) {
    this.totalAvailableArea = parseFloat(_);
  } else {
    console.warn("FlickeringMitigation.totalArea() accepts only positive numbers; unable to handle " + _);
  }
  return this;
};
FlickeringMitigation.prototype.add = function(areaError) {
  var secondToLastAreaError, secondToLastGrowth;
  secondToLastAreaError = this.lastAreaError;
  this.lastAreaError = areaError;
  if (!isNaN(secondToLastAreaError)) {
    secondToLastGrowth = this.lastGrowth;
    this.lastGrowth = direction(this.lastAreaError, secondToLastAreaError);
  }
  if (!isNaN(secondToLastGrowth)) {
    this.growthChanges.unshift(this.lastGrowth != secondToLastGrowth);
  }
  if (this.growthChanges.length > this.growthChangesLength) {
    this.growthChanges.pop();
  }
  return this;
};
FlickeringMitigation.prototype.ratio = function() {
  var weightedChangeCount = 0;
  var ratio;
  if (this.growthChanges.length < this.growthChangesLength) {
    return 0;
  }
  if (this.lastAreaError > this.totalAvailableArea / 10) {
    return 0;
  }
  for (var i = 0; i < this.growthChangesLength; i++) {
    if (this.growthChanges[i]) {
      weightedChangeCount += this.growthChangeWeights[i];
    }
  }
  ratio = weightedChangeCount / this.growthChangeWeightsSum;
  return ratio;
};

// node_modules/d3-voronoi-map/src/initial-position-policies/random.js
function random_default() {
  var clippingPolygon, extent, minX, maxX, minY, maxY, dx, dy;
  function _random(d, i, arr, voronoiMapSimulation2) {
    var shouldUpdateInternals = false;
    var x3, y3;
    if (clippingPolygon !== voronoiMapSimulation2.clip()) {
      clippingPolygon = voronoiMapSimulation2.clip();
      extent = voronoiMapSimulation2.extent();
      shouldUpdateInternals = true;
    }
    if (shouldUpdateInternals) {
      updateInternals();
    }
    x3 = minX + dx * voronoiMapSimulation2.prng()();
    y3 = minY + dy * voronoiMapSimulation2.prng()();
    while (!contains_default(clippingPolygon, [x3, y3])) {
      x3 = minX + dx * voronoiMapSimulation2.prng()();
      y3 = minY + dy * voronoiMapSimulation2.prng()();
    }
    return [x3, y3];
  }
  ;
  function updateInternals() {
    minX = extent[0][0];
    maxX = extent[1][0];
    minY = extent[0][1];
    maxY = extent[1][1];
    dx = maxX - minX;
    dy = maxY - minY;
  }
  ;
  return _random;
}

// node_modules/d3-voronoi-map/src/initial-weight-policies/half-average-area.js
function half_average_area_default() {
  var clippingPolygon, dataArray, siteCount, totalArea, halfAverageArea;
  function _halfAverageArea(d, i, arr, voronoiMapSimulation2) {
    var shouldUpdateInternals = false;
    if (clippingPolygon !== voronoiMapSimulation2.clip()) {
      clippingPolygon = voronoiMapSimulation2.clip();
      shouldUpdateInternals |= true;
    }
    if (dataArray !== arr) {
      dataArray = arr;
      shouldUpdateInternals |= true;
    }
    if (shouldUpdateInternals) {
      updateInternals();
    }
    return halfAverageArea;
  }
  ;
  function updateInternals() {
    siteCount = dataArray.length;
    totalArea = area_default(clippingPolygon);
    halfAverageArea = totalArea / siteCount / 2;
  }
  return _halfAverageArea;
}

// node_modules/d3-voronoi-map/src/d3-voronoi-map-error.js
function d3VoronoiMapError(message) {
  this.message = message;
  this.stack = new Error().stack;
}
d3VoronoiMapError.prototype.name = "d3VoronoiMapError";
d3VoronoiMapError.prototype = new Error();

// node_modules/d3-voronoi-map/src/d3-voronoi-map.js
function voronoiMapSimulation(data) {
  var DEFAULT_CONVERGENCE_RATIO = 0.01;
  var DEFAULT_MAX_ITERATION_COUNT = 50;
  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;
  var DEFAULT_PRNG = Math.random;
  var DEFAULT_INITIAL_POSITION = random_default();
  var DEFAULT_INITIAL_WEIGHT = half_average_area_default();
  var RANDOM_INITIAL_POSITION = random_default();
  var epsilon2 = 1e-10;
  var weight = function(d) {
    return d.weight;
  };
  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
  var prng = DEFAULT_PRNG;
  var initialPosition = DEFAULT_INITIAL_POSITION;
  var initialWeight = DEFAULT_INITIAL_WEIGHT;
  var weightedVoronoi2 = weightedVoronoi(), flickeringMitigation = new FlickeringMitigation(), shouldInitialize = true, siteCount, totalArea, areaErrorTreshold, iterationCount, polygons, areaError, converged, ended;
  var simulation, stepper = timer2(step), event = dispatch_default2("tick", "end");
  const HANDLE_OVERWEIGHTED_VARIANT = 1;
  const HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT = 1e3;
  var handleOverweighted;
  function sqr(d) {
    return Math.pow(d, 2);
  }
  function squaredDistance(s0, s1) {
    return sqr(s1.x - s0.x) + sqr(s1.y - s0.y);
  }
  simulation = {
    tick,
    restart: function() {
      stepper.restart(step);
      return simulation;
    },
    stop: function() {
      stepper.stop();
      return simulation;
    },
    weight: function(_) {
      if (!arguments.length) {
        return weight;
      }
      weight = _;
      shouldInitialize = true;
      return simulation;
    },
    convergenceRatio: function(_) {
      if (!arguments.length) {
        return convergenceRatio;
      }
      convergenceRatio = _;
      shouldInitialize = true;
      return simulation;
    },
    maxIterationCount: function(_) {
      if (!arguments.length) {
        return maxIterationCount;
      }
      maxIterationCount = _;
      return simulation;
    },
    minWeightRatio: function(_) {
      if (!arguments.length) {
        return minWeightRatio;
      }
      minWeightRatio = _;
      shouldInitialize = true;
      return simulation;
    },
    clip: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.clip();
      }
      weightedVoronoi2.clip(_);
      shouldInitialize = true;
      return simulation;
    },
    extent: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.extent();
      }
      weightedVoronoi2.extent(_);
      shouldInitialize = true;
      return simulation;
    },
    size: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.size();
      }
      weightedVoronoi2.size(_);
      shouldInitialize = true;
      return simulation;
    },
    prng: function(_) {
      if (!arguments.length) {
        return prng;
      }
      prng = _;
      shouldInitialize = true;
      return simulation;
    },
    initialPosition: function(_) {
      if (!arguments.length) {
        return initialPosition;
      }
      initialPosition = _;
      shouldInitialize = true;
      return simulation;
    },
    initialWeight: function(_) {
      if (!arguments.length) {
        return initialWeight;
      }
      initialWeight = _;
      shouldInitialize = true;
      return simulation;
    },
    state: function() {
      if (shouldInitialize) {
        initializeSimulation();
      }
      return {
        ended,
        iterationCount,
        convergenceRatio: areaError / totalArea,
        polygons
      };
    },
    on: function(name, _) {
      if (arguments.length === 1) {
        return event.on(name);
      }
      event.on(name, _);
      return simulation;
    }
  };
  function step() {
    tick();
    event.call("tick", simulation);
    if (ended) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick() {
    if (!ended) {
      if (shouldInitialize) {
        initializeSimulation();
      }
      polygons = adapt(polygons, flickeringMitigation.ratio());
      iterationCount++;
      areaError = computeAreaError(polygons);
      flickeringMitigation.add(areaError);
      converged = areaError < areaErrorTreshold;
      ended = converged || iterationCount >= maxIterationCount;
    }
  }
  function initializeSimulation() {
    setHandleOverweighted();
    siteCount = data.length;
    totalArea = Math.abs(area_default(weightedVoronoi2.clip()));
    areaErrorTreshold = convergenceRatio * totalArea;
    flickeringMitigation.clear().totalArea(totalArea);
    iterationCount = 0;
    converged = false;
    polygons = initialize(data, simulation);
    ended = false;
    shouldInitialize = false;
  }
  function initialize(data2, simulation2) {
    var maxWeight = data2.reduce(function(max2, d) {
      return Math.max(max2, weight(d));
    }, -Infinity), minAllowedWeight = maxWeight * minWeightRatio;
    var weights, mapPoints;
    weights = data2.map(function(d, i, arr) {
      return {
        index: i,
        weight: Math.max(weight(d), minAllowedWeight),
        initialPosition: initialPosition(d, i, arr, simulation2),
        initialWeight: initialWeight(d, i, arr, simulation2),
        originalData: d
      };
    });
    mapPoints = createMapPoints(weights, simulation2);
    handleOverweighted(mapPoints);
    return weightedVoronoi2(mapPoints);
  }
  function createMapPoints(basePoints, simulation2) {
    var totalWeight = basePoints.reduce(function(acc, bp) {
      return acc += bp.weight;
    }, 0);
    var initialPosition2;
    return basePoints.map(function(bp, i, bps) {
      initialPosition2 = bp.initialPosition;
      if (!contains_default(weightedVoronoi2.clip(), initialPosition2)) {
        initialPosition2 = DEFAULT_INITIAL_POSITION(bp, i, bps, simulation2);
      }
      return {
        index: bp.index,
        targetedArea: totalArea * bp.weight / totalWeight,
        data: bp,
        x: initialPosition2[0],
        y: initialPosition2[1],
        weight: bp.initialWeight
        // ArlindNocaj/Voronoi-Treemap-Library uses an epsilonesque initial weight; using heavier initial weights allows faster weight adjustements, hence faster stabilization
      };
    });
  }
  function adapt(polygons2, flickeringMitigationRatio) {
    var adaptedMapPoints;
    adaptPositions(polygons2, flickeringMitigationRatio);
    adaptedMapPoints = polygons2.map(function(p) {
      return p.site.originalObject;
    });
    polygons2 = weightedVoronoi2(adaptedMapPoints);
    if (polygons2.length < siteCount) {
      throw new d3VoronoiMapError("at least 1 site has no area, which is not supposed to arise");
    }
    adaptWeights(polygons2, flickeringMitigationRatio);
    adaptedMapPoints = polygons2.map(function(p) {
      return p.site.originalObject;
    });
    polygons2 = weightedVoronoi2(adaptedMapPoints);
    if (polygons2.length < siteCount) {
      throw new d3VoronoiMapError("at least 1 site has no area, which is not supposed to arise");
    }
    return polygons2;
  }
  function adaptPositions(polygons2, flickeringMitigationRatio) {
    var newMapPoints = [], flickeringInfluence = 0.5;
    var flickeringMitigation2, d, polygon, mapPoint, centroid, dx, dy;
    flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
    d = 1 - flickeringMitigation2;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      centroid = centroid_default(polygon);
      dx = centroid[0] - mapPoint.x;
      dy = centroid[1] - mapPoint.y;
      dx *= d;
      dy *= d;
      mapPoint.x += dx;
      mapPoint.y += dy;
      newMapPoints.push(mapPoint);
    }
    handleOverweighted(newMapPoints);
  }
  function adaptWeights(polygons2, flickeringMitigationRatio) {
    var newMapPoints = [], flickeringInfluence = 0.1;
    var flickeringMitigation2, polygon, mapPoint, currentArea, adaptRatio, adaptedWeight;
    flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      currentArea = area_default(polygon);
      adaptRatio = mapPoint.targetedArea / currentArea;
      adaptRatio = Math.max(adaptRatio, 1 - flickeringInfluence + flickeringMitigation2);
      adaptRatio = Math.min(adaptRatio, 1 + flickeringInfluence - flickeringMitigation2);
      adaptedWeight = mapPoint.weight * adaptRatio;
      adaptedWeight = Math.max(adaptedWeight, epsilon2);
      mapPoint.weight = adaptedWeight;
      newMapPoints.push(mapPoint);
    }
    handleOverweighted(newMapPoints);
  }
  function handleOverweighted0(mapPoints) {
    var fixCount = 0;
    var fixApplied, tpi, tpj, weightest, lightest, sqrD, adaptedWeight;
    do {
      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
        throw new d3VoronoiMapError("handleOverweighted0 is looping too much");
      }
      fixApplied = false;
      for (var i = 0; i < siteCount; i++) {
        tpi = mapPoints[i];
        for (var j = i + 1; j < siteCount; j++) {
          tpj = mapPoints[j];
          if (tpi.weight > tpj.weight) {
            weightest = tpi;
            lightest = tpj;
          } else {
            weightest = tpj;
            lightest = tpi;
          }
          sqrD = squaredDistance(tpi, tpj);
          if (sqrD < weightest.weight - lightest.weight) {
            adaptedWeight = sqrD + lightest.weight / 2;
            adaptedWeight = Math.max(adaptedWeight, epsilon2);
            weightest.weight = adaptedWeight;
            fixApplied = true;
            fixCount++;
            break;
          }
        }
        if (fixApplied) {
          break;
        }
      }
    } while (fixApplied);
  }
  function handleOverweighted1(mapPoints) {
    var fixCount = 0;
    var fixApplied, tpi, tpj, weightest, lightest, sqrD, overweight;
    do {
      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
        throw new d3VoronoiMapError("handleOverweighted1 is looping too much");
      }
      fixApplied = false;
      for (var i = 0; i < siteCount; i++) {
        tpi = mapPoints[i];
        for (var j = i + 1; j < siteCount; j++) {
          tpj = mapPoints[j];
          if (tpi.weight > tpj.weight) {
            weightest = tpi;
            lightest = tpj;
          } else {
            weightest = tpj;
            lightest = tpi;
          }
          sqrD = squaredDistance(tpi, tpj);
          if (sqrD < weightest.weight - lightest.weight) {
            overweight = weightest.weight - lightest.weight - sqrD;
            lightest.weight += overweight + epsilon2;
            fixApplied = true;
            fixCount++;
            break;
          }
        }
        if (fixApplied) {
          break;
        }
      }
    } while (fixApplied);
  }
  function computeAreaError(polygons2) {
    var areaErrorSum = 0;
    var polygon, mapPoint, currentArea;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      currentArea = area_default(polygon);
      areaErrorSum += Math.abs(mapPoint.targetedArea - currentArea);
    }
    return areaErrorSum;
  }
  function setHandleOverweighted() {
    switch (HANDLE_OVERWEIGHTED_VARIANT) {
      case 0:
        handleOverweighted = handleOverweighted0;
        break;
      case 1:
        handleOverweighted = handleOverweighted1;
        break;
      default:
        console.error("unknown 'handleOverweighted' variant; using variant #1");
        handleOverweighted = handleOverweighted0;
    }
  }
  return simulation;
}

// node_modules/d3-voronoi-treemap/src/d3-voronoi-treemap.js
function voronoiTreemap() {
  var DEFAULT_CONVERGENCE_RATIO = 0.01;
  var DEFAULT_MAX_ITERATION_COUNT = 50;
  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;
  var DEFAULT_PRNG = Math.random;
  var clip = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
  var extent = [
    [0, 0],
    [1, 1]
  ];
  var size = [1, 1];
  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
  var prng = DEFAULT_PRNG;
  var unrelevantButNeedeData = [
    {
      weight: 1
    },
    {
      weight: 1
    }
  ];
  var _convenientReusableVoronoiMapSimulation = voronoiMapSimulation(unrelevantButNeedeData).stop();
  function _voronoiTreemap(rootNode) {
    recurse(clip, rootNode);
  }
  _voronoiTreemap.convergenceRatio = function(_) {
    if (!arguments.length) {
      return convergenceRatio;
    }
    convergenceRatio = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.maxIterationCount = function(_) {
    if (!arguments.length) {
      return maxIterationCount;
    }
    maxIterationCount = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.minWeightRatio = function(_) {
    if (!arguments.length) {
      return minWeightRatio;
    }
    minWeightRatio = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.clip = function(_) {
    if (!arguments.length) {
      return clip;
    }
    _convenientReusableVoronoiMapSimulation.clip(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.extent = function(_) {
    if (!arguments.length) {
      return extent;
    }
    _convenientReusableVoronoiMapSimulation.extent(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.size = function(_) {
    if (!arguments.length) {
      return size;
    }
    _convenientReusableVoronoiMapSimulation.size(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.prng = function(_) {
    if (!arguments.length) {
      return prng;
    }
    prng = _;
    return _voronoiTreemap;
  };
  function recurse(clippingPolygon, node) {
    var simulation;
    node.polygon = clippingPolygon;
    if (node.height != 0) {
      simulation = voronoiMapSimulation(node.children).clip(clippingPolygon).weight(function(d) {
        return d.value;
      }).convergenceRatio(convergenceRatio).maxIterationCount(maxIterationCount).minWeightRatio(minWeightRatio).prng(prng).stop();
      var state = simulation.state();
      while (!state.ended) {
        simulation.tick();
        state = simulation.state();
      }
      state.polygons.forEach(function(cp) {
        recurse(cp, cp.site.originalObject.data.originalData);
      });
    }
  }
  return _voronoiTreemap;
}

// node_modules/@amcharts/amcharts5/.internal/charts/hierarchy/VoronoiTreemap.js
var import_seedrandom = __toESM(require_seedrandom2());
var VoronoiTreemap = class extends Hierarchy {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_tag", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "voronoitreemap"
    });
    Object.defineProperty(this, "polygons", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Polygon._new(this._root, {
        themeTags: mergeTags(this.polygons.template.get("themeTags", []), [this._tag, "shape"])
      }, [this.polygons.template]))
    });
    Object.defineProperty(this, "voronoi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: voronoiTreemap()
    });
  }
  _afterNew() {
    this.nodesContainer.setAll({
      x: p50,
      y: p50,
      centerX: p50,
      centerY: p50
    });
    super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    const width = this.innerWidth() / 2;
    const height = this.innerHeight() / 2;
    let node = this._rootNode;
    const selectedDataItem = this.get("selectedDataItem");
    if (selectedDataItem) {
      node = selectedDataItem.get("d3HierarchyNode");
    }
    this.voronoi.convergenceRatio(this.get("convergenceRatio", 5e-3));
    this.voronoi.maxIterationCount(this.get("maxIterationCount", 100));
    this.voronoi.minWeightRatio(this.get("minWeightRatio", 5e-3));
    if (this.isDirty("type")) {
      if (this.get("type") == "polygon") {
        this.voronoi.clip(this.getCirclePolygon(1));
        this._updateVisuals();
      }
    }
    if (this._sizeDirty) {
      if (this.get("type") == "rectangle") {
        this.voronoi.prng((0, import_seedrandom.default)("X"));
        this.voronoi.clip([[-width, -height], [-width, height], [width, height], [width, -height]])(node);
        this._updateVisuals();
      }
    }
    if ((this._valuesDirty || this.isDirty("selectedDataItem")) && node) {
      this.voronoi.prng((0, import_seedrandom.default)("X"));
      this.voronoi(node);
      this._updateVisuals();
    }
  }
  _updateNode(dataItem) {
    const coords = dataItem.get("d3HierarchyNode").polygon;
    const polygon = dataItem.get("polygon");
    if (coords && polygon) {
      let coordinates = [];
      let d = 1;
      if (this.get("type") == "polygon") {
        d = Math.min(this.innerWidth(), this.innerHeight()) / 2;
      }
      let minX = Infinity;
      let maxX = -Infinity;
      for (let i = 0, len = coords.length; i < len; i++) {
        const point = coords[i];
        let x3 = point[0] * d;
        let y3 = point[1] * d;
        coordinates.push([x3, y3]);
        minX = Math.min(minX, x3);
        maxX = Math.max(maxX, x3);
      }
      polygon.set("coordinates", coordinates);
      const fill = dataItem.get("fill");
      polygon._setDefault("fill", fill);
      const label = dataItem.get("label");
      if (label) {
        const site = coords.site;
        if (site) {
          label.setAll({
            x: site.x * d,
            y: site.y * d,
            maxWidth: Math.abs(maxX - minX)
          });
        }
      }
    }
  }
  _handleSingle(dataItem) {
    const parent = dataItem.get("parent");
    if (parent) {
      const children = parent.get("children");
      if (children) {
        each(children, (child) => {
          if (child != dataItem) {
            this.disableDataItem(child);
            child.get("node").hide();
          }
        });
      }
      this._handleSingle(parent);
    }
  }
  /**
   * @ignore
   */
  makeNode(dataItem) {
    const node = super.makeNode(dataItem);
    this._makeNode(dataItem, node);
    return node;
  }
  _makeNode(dataItem, node) {
    const polygon = node.children.moveValue(this.polygons.make(), 0);
    node.setPrivate("tooltipTarget", polygon);
    dataItem.setRaw("polygon", polygon);
    polygon._setDataItem(dataItem);
  }
  getCirclePolygon(radius) {
    const points = this.get("cornerCount", 120);
    const dAngle = Math.PI * 2 / points;
    const polygon = [];
    for (let i = 0; i < points; i++) {
      let angle = i * dAngle;
      polygon.push([radius * Math.cos(angle), radius * Math.sin(angle)]);
    }
    return polygon;
  }
};
Object.defineProperty(VoronoiTreemap, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "VoronoiTreemap"
});
Object.defineProperty(VoronoiTreemap, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Hierarchy.classNames.concat([VoronoiTreemap.className])
});
export {
  BreadcrumbBar,
  HierarchyDefaultTheme as DefaultTheme,
  ForceDirected,
  Hierarchy,
  HierarchyLink,
  HierarchyNode,
  LinkedHierarchy,
  LinkedHierarchyNode,
  Pack,
  Partition,
  Sunburst,
  Tree,
  Treemap,
  VoronoiTreemap
};
//# sourceMappingURL=@amcharts_amcharts5_hierarchy.js.map
