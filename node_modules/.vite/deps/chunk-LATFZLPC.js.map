{
  "version": 3,
  "sources": ["../../src/.internal/core/render/Circle.ts", "../../src/.internal/core/render/Polygon.ts"],
  "sourcesContent": ["import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\n\nexport interface ICircleSettings extends IGraphicsSettings {\n\n\t/**\n\t * Circle radius in pixels.\n\t */\n\tradius?: number;\n\n}\n\nexport interface ICirclePrivate extends IGraphicsPrivate {\n}\n\n/**\n * Draws a circle.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n * @important\n */\nexport class Circle extends Graphics {\n\n\tdeclare public _settings: ICircleSettings;\n\tdeclare public _privateSettings: ICirclePrivate;\n\n\tpublic static className: string = \"Circle\";\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([Circle.className]);\n\n\tpublic _afterNew(){\n\t\tsuper._afterNew();\n\t\tthis._display.isMeasured = true;\n\t\tthis.setPrivateRaw(\"trustBounds\", true);\n\t}\t\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"radius\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\t\t\tthis._display.drawCircle(0, 0, this.get(\"radius\", 10));\n\t\t}\n\t}\n}\n", "import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\r\nimport type { IPoint } from \"../util/IPoint\";\r\nimport * as $array from \"../util/Array\";\r\n\r\nimport type { Time } from \"../util/Animation\";\r\nimport type { Animation } from \"../util/Entity\";\r\n\r\nexport interface IPolygonSettings extends IGraphicsSettings {\r\n\r\n\t/**\r\n\t * An array of polygon corner coordinates.\r\n\t */\r\n\tpoints?: Array<IPoint>;\r\n\r\n\t/**\r\n\t * Corodinates.\r\n\t */\r\n\tcoordinates?: Array<Array<number>>;\r\n\r\n\t/**\r\n\t * Number of milliseconds to play morph animation.\r\n\t */\r\n\tanimationDuration?: number;\r\n\r\n\t/**\r\n\t * Easing function to use for animations.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Easing_functions} for more info\r\n\t */\r\n\tanimationEasing?: (t: Time) => Time;\r\n\r\n}\r\n\r\nexport interface IPolygonPrivate extends IGraphicsPrivate {\r\n\tpoints?: Array<IPoint>;\r\n\r\n\tpreviousPoints?: Array<IPoint>;\r\n\r\n\tmorphProgress?: number;\r\n\r\n\tminX?: number;\r\n\r\n\tmaxX?: number;\r\n\r\n\tminY?: number;\r\n\r\n\tmaxY?: number;\r\n}\r\n\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/polygon/} for more info\r\n * @important\r\n * @since 5.4.0\r\n */\r\nexport class Polygon extends Graphics {\r\n\r\n\tdeclare public _settings: IPolygonSettings;\r\n\tdeclare public _privateSettings: IPolygonPrivate;\r\n\r\n\tpublic static className: string = \"Polygon\";\r\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([Polygon.className]);\r\n\r\n\tpublic morphAnimation?: Animation<this[\"_privateSettings\"][\"morphProgress\"]>;\r\n\r\n\tpublic _beforeChanged() {\r\n\t\tsuper._beforeChanged();\r\n\t\tif (this.isDirty(\"coordinates\")) {\r\n\t\t\tconst points: Array<IPoint> = [];\r\n\t\t\tconst coordinates = this.get(\"coordinates\");\r\n\t\t\tif (coordinates) {\r\n\t\t\t\t$array.each(coordinates, (coord) => {\r\n\t\t\t\t\tpoints.push({ x: coord[0], y: coord[1] });\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tthis.set(\"points\", points);\r\n\t\t}\r\n\t\tif (this.isPrivateDirty(\"points\")) {\r\n\t\t\tthis._clear = true;\r\n\t\t}\r\n\r\n\t\tif (this.isDirty(\"points\")) {\r\n\t\t\tthis._clear = true;\r\n\r\n\t\t\tconst points = this.get(\"points\");\r\n\t\t\tconst prevPoints = this._prevSettings.points;\r\n\t\t\tif (prevPoints) {\r\n\t\t\t\tif (points) {\r\n\t\t\t\t\tlet copy = $array.copy(points);\r\n\t\t\t\t\tlet prevCopy = $array.copy(prevPoints);\r\n\t\t\t\t\tlet cl = copy.length;\r\n\t\t\t\t\tlet pl = prevCopy.length;\r\n\r\n\t\t\t\t\tif (cl > pl) {\r\n\t\t\t\t\t\tlet newCopy = $array.copy(copy);\r\n\t\t\t\t\t\tfor (let i = 0; i < cl; i++) {\r\n\t\t\t\t\t\t\tlet index = Math.floor(i / cl * pl);\r\n\t\t\t\t\t\t\tnewCopy[i] = { x: prevCopy[index].x, y: prevCopy[index].y };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tprevCopy = newCopy;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (pl > cl) {\r\n\t\t\t\t\t\tlet newCopy = $array.copy(prevCopy);\r\n\t\t\t\t\t\tfor (let i = 0; i < pl; i++) {\r\n\t\t\t\t\t\t\tlet index = Math.floor(i / pl * cl);\r\n\t\t\t\t\t\t\tnewCopy[i] = { x: copy[index].x, y: copy[index].y };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcopy = newCopy;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.setPrivateRaw(\"previousPoints\", prevCopy);\r\n\t\t\t\t\tthis.setPrivateRaw(\"points\", copy);\r\n\t\t\t\t\tthis.morphAnimation = this.animatePrivate({ key: \"morphProgress\", from: 0, to: 1, duration: this.get(\"animationDuration\", 0), easing: this.get(\"animationEasing\") });\r\n\t\t\t\t\t// solves no animated theme\r\n\t\t\t\t\tthis._root.events.once(\"frameended\", ()=>{\r\n\t\t\t\t\t\tthis._markDirtyPrivateKey(\"morphProgress\");\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.setPrivateRaw(\"previousPoints\", points);\r\n\t\t\t\tthis.setPrivateRaw(\"points\", points);\r\n\t\t\t}\r\n\t\t\tlet minX = Infinity;\r\n\t\t\tlet maxX = -Infinity;\r\n\t\t\tlet minY = Infinity;\r\n\t\t\tlet maxY = -Infinity;\r\n\r\n\t\t\tif (points) {\r\n\t\t\t\tfor (let i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\t\tconst point = points[i];\r\n\t\t\t\t\tminX = Math.min(minX, point.x);\r\n\t\t\t\t\tmaxX = Math.max(maxX, point.x);\r\n\r\n\t\t\t\t\tminY = Math.min(minY, point.y);\r\n\t\t\t\t\tmaxY = Math.max(maxY, point.y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setPrivate(\"minX\", minX);\r\n\t\t\tthis.setPrivate(\"maxX\", maxX);\r\n\t\t\tthis.setPrivate(\"minY\", minY);\r\n\t\t\tthis.setPrivate(\"maxY\", minY);\r\n\t\t}\r\n\r\n\r\n\r\n\t\tif (this.isPrivateDirty(\"morphProgress\")) {\r\n\t\t\tthis._clear = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _changed() {\r\n\t\tsuper._changed();\r\n\r\n\t\tif (this._clear) {\r\n\t\t\tthis._draw();\r\n\t\t}\r\n\t}\r\n\r\n\tprotected _draw() {\r\n\t\tconst previousPoints = this.getPrivate(\"previousPoints\");\r\n\t\tconst points = this.getPrivate(\"points\");\r\n\t\tconst morphProgress = this.getPrivate(\"morphProgress\", 1);\r\n\r\n\t\tif (points && previousPoints) {\r\n\t\t\tconst first = points[0];\r\n\t\t\tconst prevFirst = previousPoints[0];\r\n\t\t\tif (first) {\r\n\t\t\t\tthis._display.moveTo(prevFirst.x + (first.x - prevFirst.x) * morphProgress, prevFirst.y + (first.y - prevFirst.y) * morphProgress);\r\n\t\t\t}\r\n\t\t\tfor (let i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tconst point = points[i];\r\n\t\t\t\tconst prevPoint = previousPoints[i];\r\n\t\t\t\tthis._display.lineTo(prevPoint.x + (point.x - prevPoint.x) * morphProgress, prevPoint.y + (point.y - prevPoint.y) * morphProgress);\r\n\t\t\t}\r\n\t\t\tthis._display.closePath();\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _updateSize() {\r\n\t\tthis.markDirty()\r\n\t\tthis._clear = true;\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["copy"]
}
