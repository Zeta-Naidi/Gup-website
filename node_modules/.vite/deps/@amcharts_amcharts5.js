import {
  Scrollbar
} from "./chunk-COGZL5WN.js";
import {
  Circle,
  Polygon
} from "./chunk-SKB4T4QD.js";
import {
  Button,
  Chart,
  Line,
  SerialChart,
  Tick
} from "./chunk-UNBH4MGR.js";
import {
  Slice
} from "./chunk-MD6PYTY6.js";
import {
  ColorSet,
  Component,
  DataItem,
  JsonData,
  ListData,
  RadialLabel,
  RadialText,
  RoundedRectangle,
  Series,
  Time_exports
} from "./chunk-M3WCBVCU.js";
import {
  DateFormatter,
  DurationFormatter,
  InterfaceColors,
  NumberFormatter,
  PointedRectangle,
  Root,
  Timezone,
  Tooltip
} from "./chunk-NHIRBM7B.js";
import {
  BlendMode,
  Color,
  Container,
  Ease_exports,
  Entity,
  Graphics,
  GridLayout,
  HorizontalLayout,
  Label,
  Layout,
  ListTemplate,
  Math_exports,
  Pattern,
  Percent,
  PicturePattern,
  Rectangle,
  Sprite,
  StyleRule,
  Text,
  TextFormatter,
  Utils_exports,
  VerticalLayout,
  addEventListener,
  addLicense,
  color,
  cos,
  disposeAllRootElements,
  getAngle,
  getShadowRoot,
  mergeTags,
  p0,
  p100,
  p50,
  percent,
  ready,
  registry,
  relativeToValue,
  sin,
  supports
} from "./chunk-7PJVI6CE.js";
import {
  ArrayDisposer,
  Array_exports,
  CounterDisposer,
  Disposer,
  MultiDisposer,
  MutableValueDisposer,
  Object_exports,
  Template,
  Theme,
  Type_exports,
  each,
  each2,
  isArray,
  isNumber,
  isObject,
  isString,
  toNumber
} from "./chunk-DNCBPH6C.js";
import {
  __export
} from "./chunk-UV5CTPV7.js";

// node_modules/@amcharts/amcharts5/.internal/core/util/Modal.js
var rules;
function modalCSS(element, root, _prefix) {
  const ic = root.interfaceColors;
  const active = ic.get("secondaryButton").toCSS();
  const text = ic.get("text").toCSS();
  const shadow = ic.get("alternativeBackground").toCSS(0.45);
  if (!rules) {
    const disposer = new MultiDisposer([
      new StyleRule(element, ".am5-modal", {
        "width": "100%",
        "height": "100%",
        "position": "absolute",
        "z-index": "100000",
        "top": "0",
        "left": "0"
      }),
      new StyleRule(element, ".am5-modal-curtain", {
        "top": "0",
        "left": "0",
        "width": "100%",
        "height": "100%",
        "position": "absolute",
        "background": ic.get("background").toCSS(0.5),
        "z-index": "100"
      }),
      new StyleRule(element, ".am5-modal-wrapper", {
        "top": "0",
        "left": "0",
        "width": "100%",
        "height": "100%",
        "position": "absolute",
        "text-align": "center",
        "white-space": "nowrap",
        "background": ic.get("background").toCSS(0.5),
        "z-index": "101"
      }),
      new StyleRule(element, ".am5-modal-wrapper:before", {
        "content": "''",
        "display": "inline-block",
        "height": "100%",
        "vertical-align": "middle",
        "margin-right": "-0.25em"
      }),
      new StyleRule(element, ".am5-modal-content", {
        "display": "inline-block",
        "padding": "1.2em",
        "vertical-align": "middle",
        "text-align": "left",
        "white-space": "normal",
        "background": ic.get("background").toCSS(),
        //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
        "border-radius": "4px",
        "-webkit-box-shadow": "0px 0px 36px 0px " + shadow,
        "box-shadow": "0px 0px 36px 0px " + shadow,
        "color": text
      }),
      new StyleRule(element, ".am5-modal-content h1", {
        "font-size": "1em",
        "margin": "0 0 0.5em 0"
      }),
      new StyleRule(element, ".am5-modal-table", {
        "display": "table",
        "margin": "1em 0"
      }),
      new StyleRule(element, ".am5-modal-table-row", {
        "display": "table-row"
      }),
      new StyleRule(element, ".am5-modal-table-heading", {
        "display": "table-heading",
        "padding": "3px 10px 3px 0"
      }),
      new StyleRule(element, ".am5-modal-table-cell", {
        "display": "table-cell",
        "padding": "3px 0 3px 0"
      }),
      new StyleRule(element, ".am5-modal-table-cell > *", {
        "vertical-align": "middle"
      }),
      new StyleRule(element, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
        "border": "1px solid " + active,
        "border-radius": "4px",
        "padding": "3px 5px",
        "margin": "2px"
      }),
      new StyleRule(element, ".am5-modal-input-narrow", {
        "width": "50px"
      }),
      new StyleRule(element, ".am5-modal-button", {
        "font-weight": "400",
        "color": ic.get("secondaryButtonText").toCSS(),
        "line-height": "1.5",
        "text-align": "center",
        "text-decoration": "none",
        "vertical-align": "middle",
        "cursor": "pointer",
        "padding": "0.2em 0.8em",
        "font-size": "1em",
        "border-radius": "0.25em",
        "margin": "0 0.25em 0 0",
        "border": "1px solid " + ic.get("secondaryButtonStroke").toCSS(),
        "background": ic.get("secondaryButton").toCSS()
      }),
      new StyleRule(element, ".am5-modal-button:hover", {
        "background": ic.get("secondaryButtonHover").toCSS()
      }),
      new StyleRule(element, ".am5-modal-button.am5-modal-primary", {
        "color": ic.get("primaryButtonText").toCSS(),
        "border": "1px solid " + ic.get("primaryButtonStroke").toCSS(),
        "background": ic.get("primaryButton").toCSS()
      }),
      new StyleRule(element, ".am5-modal-button.am5-modal-primary:hover", {
        "background": ic.get("primaryButtonHover").toCSS()
      })
    ]);
    rules = new CounterDisposer(() => {
      rules = void 0;
      disposer.dispose();
    });
  }
  return rules.increment();
}
var Modal = class extends Entity {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes();
    this._setRawDefault("deactivateRoot", true);
    modalCSS(getShadowRoot(this._root.dom), this._root);
    const container = document.createElement("div");
    container.className = "am5-modal";
    container.style.display = "none";
    this.root._inner.appendChild(container);
    this.setPrivate("container", container);
    const curtain = document.createElement("div");
    curtain.className = "am5-modal-curtain";
    container.appendChild(curtain);
    this.setPrivate("curtain", curtain);
    this._disposers.push(addEventListener(curtain, "click", () => {
      this.cancel();
    }));
    const wrapper = document.createElement("div");
    wrapper.className = "am5-modal-wrapper";
    container.appendChild(wrapper);
    this.setPrivate("wrapper", wrapper);
    const content = document.createElement("div");
    content.className = "am5-modal-content";
    wrapper.appendChild(content);
    this.setPrivate("content", content);
    const html = this.get("content");
    if (html) {
      content.innerHTML = html;
    }
    if (supports("keyboardevents")) {
      this._disposers.push(addEventListener(document, "keydown", (ev) => {
        if (this.isOpen() && ev.keyCode == 27) {
          this.cancel();
        }
      }));
    }
  }
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("content")) {
      this.getPrivate("content").innerHTML = this.get("content", "");
    }
  }
  /**
   * Returns `true` if modal is currently open.
   *
   * @return  Modal open?
   */
  isOpen() {
    return this.getPrivate("container").style.display != "none";
  }
  /**
   * Opens modal.
   */
  open() {
    this.getPrivate("container").style.display = "block";
    if (this.get("deactivateRoot")) {
      this.setTimeout(() => {
        this._root._renderer.interactionsEnabled = false;
      }, 10);
    }
    this.events.dispatch("opened", {
      type: "opened",
      target: this
    });
  }
  /**
   * Closes modal.
   */
  close() {
    this.getPrivate("container").style.display = "none";
    if (this.get("deactivateRoot")) {
      this._root._renderer.interactionsEnabled = true;
    }
    this.events.dispatch("closed", {
      type: "closed",
      target: this
    });
  }
  /**
   * Closes modal and invokes `cancelled` event.
   */
  cancel() {
    this.getPrivate("container").style.display = "none";
    if (this.get("deactivateRoot")) {
      this._root._renderer.interactionsEnabled = true;
    }
    this.events.dispatch("cancelled", {
      type: "cancelled",
      target: this
    });
  }
  /**
   * Disposes modal.
   */
  dispose() {
    super.dispose();
    const container = this.getPrivate("container");
    if (container.parentElement) {
      container.parentElement.removeChild(container);
    }
  }
};
Object.defineProperty(Modal, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Modal"
});
Object.defineProperty(Modal, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Entity.classNames.concat([Modal.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js
var Bullet = class extends Entity {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "series", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("sprite")) {
      const sprite = this.get("sprite");
      if (sprite) {
        sprite.setAll({ position: "absolute", role: "figure" });
        this._disposers.push(sprite);
      }
    }
    if (this.isDirty("locationX") || this.isDirty("locationY")) {
      if (this.series) {
        this.series._positionBullet(this);
      }
    }
  }
};
Object.defineProperty(Bullet, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Bullet"
});
Object.defineProperty(Bullet, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Entity.classNames.concat([Bullet.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Ellipse.js
var Ellipse = class extends Graphics {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) {
      this._clear = true;
    }
  }
  _changed() {
    super._changed();
    if (this._clear) {
      this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
    }
  }
};
Object.defineProperty(Ellipse, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Ellipse"
});
Object.defineProperty(Ellipse, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Graphics.classNames.concat([Ellipse.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Star.js
var Star = class extends Graphics {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) {
      this._clear = true;
    }
  }
  _changed() {
    super._changed();
    if (this._clear) {
      const display = this._display;
      const r = this.get("radius", 0);
      const ir = relativeToValue(this.get("innerRadius", 0), r);
      const spikes = this.get("spikes", 0);
      const step = Math.PI / spikes;
      let angle = Math.PI / 2 * 3;
      display.moveTo(0, -r);
      for (let i = 0; i < spikes; i++) {
        display.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        angle += step;
        display.lineTo(Math.cos(angle) * ir, Math.sin(angle) * ir);
        angle += step;
      }
      display.lineTo(0, -r);
      display.closePath();
    }
  }
};
Object.defineProperty(Star, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Star"
});
Object.defineProperty(Star, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Graphics.classNames.concat([Star.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js
var Gradient = class extends Entity {
  _afterNew() {
    super._afterNewApplyThemes();
  }
  /**
   * @ignore
   */
  getFill(_target) {
    return {
      addColorStop: (_offset, _color) => {
      }
    };
  }
  _changed() {
    super._changed();
  }
  /**
   * @ignore
   */
  getBounds(target) {
    const gradientTarget = this.get("target");
    if (gradientTarget) {
      let bounds = gradientTarget.globalBounds();
      const p02 = target.toLocal({ x: bounds.left, y: bounds.top });
      const p1 = target.toLocal({ x: bounds.right, y: bounds.top });
      const p2 = target.toLocal({ x: bounds.right, y: bounds.bottom });
      const p3 = target.toLocal({ x: bounds.left, y: bounds.bottom });
      return {
        left: Math.min(p02.x, p1.x, p2.x, p3.x),
        top: Math.min(p02.y, p1.y, p2.y, p3.y),
        right: Math.max(p02.x, p1.x, p2.x, p3.x),
        bottom: Math.max(p02.y, p1.y, p2.y, p3.y)
      };
    }
    return target._display.getLocalBounds();
  }
};
Object.defineProperty(Gradient, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Gradient"
});
Object.defineProperty(Gradient, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Entity.classNames.concat([Gradient.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/gradients/LinearGradient.js
var LinearGradient = class extends Gradient {
  /**
   * @ignore
   */
  getFill(target) {
    const rotation = this.get("rotation", 0);
    let bounds = this.getBounds(target);
    let l = bounds.left || 0;
    let r = bounds.right || 0;
    let t = bounds.top || 0;
    let b = bounds.bottom || 0;
    let cos2 = cos(rotation);
    let sin2 = sin(rotation);
    let w = cos2 * (r - l);
    let h = sin2 * (b - t);
    let longer = Math.max(w, h);
    const gradient = this._root._renderer.createLinearGradient(l, t, l + longer * cos2, t + longer * sin2);
    const stops = this.get("stops");
    if (stops) {
      let i = 0;
      each(stops, (stop) => {
        let offset = stop.offset;
        if (!isNumber(offset)) {
          offset = i / (stops.length - 1);
        }
        let opacity = stop.opacity;
        if (!isNumber(opacity)) {
          opacity = 1;
        }
        let color2 = stop.color;
        if (color2) {
          const lighten = stop.lighten;
          if (lighten) {
            color2 = Color.lighten(color2, lighten);
          }
          const brighten = stop.brighten;
          if (brighten) {
            color2 = Color.brighten(color2, brighten);
          }
          gradient.addColorStop(offset, "rgba(" + color2.r + "," + color2.g + "," + color2.b + "," + opacity + ")");
        }
        i++;
      });
    }
    return gradient;
  }
};
Object.defineProperty(LinearGradient, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "LinearGradient"
});
Object.defineProperty(LinearGradient, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Gradient.classNames.concat([LinearGradient.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/HeatLegend.js
var HeatLegend = class extends Container {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "labelContainer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.children.push(Container.new(this._root, {}))
    });
    Object.defineProperty(this, "markerContainer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.children.push(Container.new(this._root, {}))
    });
    Object.defineProperty(this, "startLabel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.labelContainer.children.push(Label.new(this._root, { themeTags: ["start"] }))
    });
    Object.defineProperty(this, "endLabel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.labelContainer.children.push(Label.new(this._root, { themeTags: ["end"] }))
    });
    Object.defineProperty(this, "markers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
        themeTags: mergeTags(this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
      }, [this.markers.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["heatlegend", this._settings.orientation]);
    super._afterNew();
    this.set("tooltip", Tooltip.new(this._root, {
      themeTags: ["heatlegend"]
    }));
  }
  /**
   * @ignore
   */
  makeMarker() {
    const marker = this.markers.make();
    marker.states.create("disabled", {});
    return marker;
  }
  /**
   * Moves and shows tooltip at specific value.
   *
   * Can also specify optional text to show in tooltip, as well as the color.
   *
   * @param  value  Value
   * @param  text   Text
   * @param  color  Color
   */
  showValue(value, text, color2) {
    const tooltip = this.getTooltip();
    if (tooltip && isNumber(value)) {
      const startValue = this.get("startValue", 0);
      const endValue = this.get("endValue", 1);
      const c = (value - startValue) / (endValue - startValue);
      const startColor = this.get("startColor");
      const endColor = this.get("endColor");
      if (!text) {
        text = this.getNumberFormatter().format(value);
      }
      if (!color2) {
        color2 = Color.interpolate(c, startColor, endColor);
      }
      tooltip.label.set("text", text);
      let p;
      if (this.get("orientation") == "vertical") {
        p = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - c) });
      } else {
        p = this.markerContainer.toGlobal({ x: this.innerWidth() * c, y: 0 });
      }
      let background = tooltip.get("background");
      if (background) {
        background.set("fill", Color.interpolate(c, startColor, endColor));
      }
      tooltip.set("pointTo", p);
      tooltip.show();
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    const labelContainer = this.labelContainer;
    const orientation = this.get("orientation");
    const startLabel = this.startLabel;
    const endLabel = this.endLabel;
    const tooltip = this.getTooltip();
    if (this.isDirty("orientation")) {
      if (orientation == "vertical") {
        this.markerContainer.setAll({ layout: this._root.verticalLayout, height: p100 });
        this.set("layout", this._root.horizontalLayout);
        startLabel.setAll({ y: p100, x: void 0, centerY: p100, centerX: p100 });
        endLabel.setAll({ y: 0, x: void 0, centerY: 0, centerX: p100 });
        labelContainer.setAll({ height: p100, width: void 0 });
        if (tooltip) {
          tooltip.set("pointerOrientation", "horizontal");
        }
      } else {
        this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: p100 });
        this.set("layout", this._root.verticalLayout);
        startLabel.setAll({ x: 0, y: void 0, centerX: 0, centerY: 0 });
        endLabel.setAll({ x: p100, y: void 0, centerX: p100, centerY: 0 });
        labelContainer.setAll({ width: p100, height: void 0 });
        if (tooltip) {
          tooltip.set("pointerOrientation", "vertical");
        }
      }
    }
    if (this.isDirty("stepCount")) {
      const stepCount = this.get("stepCount", 1);
      const startColor = this.get("startColor");
      const endColor = this.get("endColor");
      this.markerContainer.children.clear();
      if (stepCount > 1) {
        for (let i = 0; i < stepCount; i++) {
          const marker = this.makeMarker();
          if (orientation == "vertical") {
            this.markerContainer.children.moveValue(marker, 0);
          } else {
            this.markerContainer.children.push(marker);
          }
          if (startColor && endColor) {
            marker.set("fill", Color.interpolate(i / stepCount, startColor, endColor));
          }
        }
      } else if (stepCount == 1) {
        const marker = this.makeMarker();
        this.markerContainer.children.push(marker);
        const gradient = LinearGradient.new(this._root, { stops: [{ color: startColor }, { color: endColor }] });
        if (orientation == "vertical") {
          gradient.set("rotation", 90);
          let stops = gradient.get("stops");
          if (stops) {
            stops.reverse();
          }
        } else {
          gradient.set("rotation", 0);
        }
        if (startColor && endColor) {
          marker.set("fillGradient", gradient);
        }
      }
    }
    if (this.isDirty("startText") || this.isDirty("startValue")) {
      startLabel.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0))));
    }
    if (this.isDirty("endText") || this.isDirty("endValue")) {
      endLabel.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
    }
  }
};
Object.defineProperty(HeatLegend, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "HeatLegend"
});
Object.defineProperty(HeatLegend, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Container.classNames.concat([HeatLegend.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js
var Legend = class extends Series {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "itemContainers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Container._new(this._root, {
        themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
        themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
        background: RoundedRectangle.new(this._root, {
          themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
          themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
        })
      }, [this.itemContainers.template]))
    });
    Object.defineProperty(this, "markers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Container._new(this._root, {
        themeTags: mergeTags(this.markers.template.get("themeTags", []), ["legend", "marker"])
      }, [this.markers.template]))
    });
    Object.defineProperty(this, "labels", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Label._new(this._root, {
        themeTags: mergeTags(this.labels.template.get("themeTags", []), ["legend", "label"])
      }, [this.labels.template]))
    });
    Object.defineProperty(this, "valueLabels", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => Label._new(this._root, {
        themeTags: mergeTags(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
      }, [this.valueLabels.template]))
    });
    Object.defineProperty(this, "markerRectangles", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
        themeTags: mergeTags(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
      }, [this.markerRectangles.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["legend"]);
    this.fields.push("name", "stroke", "fill");
    super._afterNew();
  }
  /**
   * @ignore
   */
  makeItemContainer(dataItem) {
    const itemContainer = this.children.push(this.itemContainers.make());
    itemContainer._setDataItem(dataItem);
    this.itemContainers.push(itemContainer);
    itemContainer.states.create("disabled", {});
    return itemContainer;
  }
  /**
   * @ignore
   */
  makeMarker() {
    const marker = this.markers.make();
    this.markers.push(marker);
    marker.states.create("disabled", {});
    return marker;
  }
  /**
   * @ignore
   */
  makeLabel() {
    const label = this.labels.make();
    label.states.create("disabled", {});
    return label;
  }
  /**
   * @ignore
   */
  makeValueLabel() {
    const valueLabel = this.valueLabels.make();
    valueLabel.states.create("disabled", {});
    return valueLabel;
  }
  /**
   * @ignore
   */
  makeMarkerRectangle() {
    const markerRectangle = this.markerRectangles.make();
    markerRectangle.states.create("disabled", {});
    return markerRectangle;
  }
  processDataItem(dataItem) {
    super.processDataItem(dataItem);
    const itemContainer = this.makeItemContainer(dataItem);
    const nameField = this.get("nameField");
    const fillField = this.get("fillField");
    const strokeField = this.get("strokeField");
    if (itemContainer) {
      const clickTarget = this.get("clickTarget", "itemContainer");
      const item = dataItem.dataContext;
      if (item && item.set) {
        item.set("legendDataItem", dataItem);
      }
      itemContainer._setDataItem(dataItem);
      dataItem.set("itemContainer", itemContainer);
      const marker = this.makeMarker();
      if (marker) {
        itemContainer.children.push(marker);
        marker._setDataItem(dataItem);
        dataItem.set("marker", marker);
        const useDefaultMarker = this.get("useDefaultMarker");
        const markerRectangle = marker.children.push(this.makeMarkerRectangle());
        let fill = dataItem.get("fill");
        let stroke = dataItem.get("stroke");
        dataItem.set("markerRectangle", markerRectangle);
        if (item && item.get) {
          fill = item.get(fillField, fill);
          stroke = item.get(strokeField, stroke);
        }
        if (!stroke) {
          stroke = fill;
        }
        if (!useDefaultMarker) {
          if (item && item.createLegendMarker) {
            item.createLegendMarker();
          }
        } else {
          if (item.on) {
            item.on(fillField, () => {
              markerRectangle.set("fill", item.get(fillField));
            });
            item.on(strokeField, () => {
              markerRectangle.set("stroke", item.get(strokeField));
            });
          }
        }
        markerRectangle.setAll({ fill, stroke });
        const component = item.component;
        if (component && component.updateLegendMarker) {
          component.updateLegendMarker(item);
        }
      }
      const label = this.makeLabel();
      if (label) {
        itemContainer.children.push(label);
        label._setDataItem(dataItem);
        dataItem.set("label", label);
        label.text.on("text", () => {
          itemContainer.setRaw("ariaLabel", label.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : ""));
          itemContainer.markDirtyAccessibility();
        });
        if (item && item.get) {
          dataItem.set("name", item.get(nameField));
        }
        let name = dataItem.get("name");
        if (name) {
          label.set("text", name);
        }
      }
      const valueLabel = this.makeValueLabel();
      if (valueLabel) {
        itemContainer.children.push(valueLabel);
        valueLabel._setDataItem(dataItem);
        dataItem.set("valueLabel", valueLabel);
      }
      if (item && item.show) {
        item.on("visible", (visible) => {
          itemContainer.set("disabled", !visible);
        });
        if (!item.get("visible")) {
          itemContainer.set("disabled", true);
        }
        if (clickTarget != "none") {
          let clickContainer = itemContainer;
          if (clickTarget == "marker") {
            clickContainer = marker;
          }
          this._addClickEvents(clickContainer, item, dataItem);
        }
      }
      this.children.values.sort((a, b) => {
        const targetA = a.dataItem.dataContext;
        const targetB = b.dataItem.dataContext;
        if (targetA && targetB) {
          const indexA = this.data.indexOf(targetA);
          const indexB = this.data.indexOf(targetB);
          if (indexA > indexB) {
            return 1;
          } else if (indexA < indexB) {
            return -1;
          }
        }
        return 0;
      });
      if (item && item.updateLegendValue) {
        item.updateLegendValue();
      }
    }
  }
  _addClickEvents(container, item, dataItem) {
    container.set("cursorOverStyle", "pointer");
    container.events.on("pointerover", () => {
      const component = item.component;
      if (component && component.hoverDataItem) {
        component.hoverDataItem(item);
      }
    });
    container.events.on("pointerout", () => {
      const component = item.component;
      if (component && component.hoverDataItem) {
        component.unhoverDataItem(item);
      }
    });
    container.events.on("click", () => {
      const labelText = dataItem.get("label").text._getText();
      if (item.show && item.isHidden && (item.isHidden() || item.get("visible") === false)) {
        item.show();
        container.set("disabled", false);
        this._root.readerAlert(this._t("%1 shown", this._root.locale, labelText));
      } else if (item.hide) {
        item.hide();
        container.set("disabled", true);
        this._root.readerAlert(this._t("%1 hidden", this._root.locale, labelText));
      }
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(dataItem) {
    super.disposeDataItem(dataItem);
    const dataContext = dataItem.dataContext;
    if (dataContext && dataContext.get) {
      const di = dataContext.get("legendDataItem");
      if (di == dataItem) {
        dataContext.set("legendDataItem", void 0);
      }
    }
    let itemContainer = dataItem.get("itemContainer");
    if (itemContainer) {
      this.itemContainers.removeValue(itemContainer);
      itemContainer.dispose();
    }
    let marker = dataItem.get("marker");
    if (marker) {
      this.markers.removeValue(marker);
      marker.dispose();
    }
    let markerRectangle = dataItem.get("markerRectangle");
    if (markerRectangle) {
      this.markerRectangles.removeValue(markerRectangle);
      markerRectangle.dispose();
    }
    let label = dataItem.get("label");
    if (label) {
      this.labels.removeValue(label);
      label.dispose();
    }
    let valueLabel = dataItem.get("valueLabel");
    if (valueLabel) {
      this.valueLabels.removeValue(valueLabel);
      valueLabel.dispose();
    }
  }
};
Object.defineProperty(Legend, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Legend"
});
Object.defineProperty(Legend, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Series.classNames.concat([Legend.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Picture.js
var Picture = class extends Sprite {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_display", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this._root._renderer.makePicture(void 0)
    });
  }
  _changed() {
    super._changed();
    if (this.isDirty("width")) {
      const width = this.get("width");
      this._display.width = isNumber(width) ? width : void 0;
    }
    if (this.isDirty("height")) {
      const height = this.get("height");
      this._display.height = isNumber(height) ? height : void 0;
    }
    if (this.isDirty("shadowColor")) {
      this._display.clear();
      const shadowColor = this.get("shadowColor");
      this._display.shadowColor = shadowColor == null ? void 0 : shadowColor;
    }
    if (this.isDirty("shadowBlur")) {
      this._display.clear();
      this._display.shadowBlur = this.get("shadowBlur");
    }
    if (this.isDirty("shadowOffsetX")) {
      this._display.clear();
      this._display.shadowOffsetX = this.get("shadowOffsetX");
    }
    if (this.isDirty("shadowOffsetY")) {
      this._display.clear();
      this._display.shadowOffsetY = this.get("shadowOffsetY");
    }
    if (this.isDirty("shadowOpacity")) {
      this._display.clear();
      this._display.shadowOpacity = this.get("shadowOpacity");
    }
    if (this.isDirty("src") || this.isDirty("cors")) {
      this._display.clear();
      this._load();
    }
  }
  _load() {
    const src = this.get("src");
    if (src) {
      let eventType = "loaded";
      const image = new Image();
      image.crossOrigin = this.get("cors", "anonymous");
      image.src = src;
      image.decode().then(() => {
        this._display.image = image;
        this._updateSize();
      }).catch((_error) => {
        eventType = "loaderror";
      });
      if (this.events.isEnabled(eventType)) {
        this.events.dispatch(eventType, { type: eventType, target: this });
      }
    }
  }
  _updateSize() {
    super._updateSize();
    const image = this._display.image;
    if (image) {
      let w = this.getPrivate("width", this.get("width"));
      let h = this.getPrivate("height", this.get("height"));
      const r = image.width && image.height ? image.width / image.height : 0;
      if (isNumber(w) && isNumber(h)) {
        this._display.width = w;
        this._display.height = h;
      } else if (isNumber(w) && r) {
        h = w / r;
      } else if (isNumber(h) && r) {
        w = h * r;
      } else {
        w = image.width;
        h = image.height;
      }
      if (isNumber(w)) {
        this._display.width = w;
      }
      if (isNumber(h)) {
        this._display.height = h;
      }
      this.markDirtyBounds();
      this.markDirty();
    }
  }
};
Object.defineProperty(Picture, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Picture"
});
Object.defineProperty(Picture, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Sprite.classNames.concat([Picture.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js
var Triangle = class extends Graphics {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
      this._clear = true;
    }
  }
  _changed() {
    super._changed();
    if (this._clear && !this.get("draw")) {
      this._draw();
    }
  }
  _draw() {
    const w = this.width();
    const h = this.height();
    const display = this._display;
    display.moveTo(-w / 2, h / 2);
    display.lineTo(0, -h / 2);
    display.lineTo(w / 2, h / 2);
    display.lineTo(-w / 2, h / 2);
    display.closePath();
  }
  _updateSize() {
    this.markDirty();
    this._clear = true;
  }
};
Object.defineProperty(Triangle, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Triangle"
});
Object.defineProperty(Triangle, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Graphics.classNames.concat([Triangle.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/Slider.js
var Slider = class extends Scrollbar {
  _afterNew() {
    this._addOrientationClass();
    super._afterNew();
    this.endGrip.setPrivate("visible", false);
    this.thumb.setPrivate("visible", false);
  }
  /**
   * @ignore
   */
  updateGrips() {
    super.updateGrips();
    const startGrip = this.startGrip;
    this.endGrip.setAll({ x: startGrip.x(), y: startGrip.y() });
    this.setRaw("end", this.get("start"));
  }
};
Object.defineProperty(Slider, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Slider"
});
Object.defineProperty(Slider, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Scrollbar.classNames.concat([Slider.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/patterns/GrainPattern.js
var GrainPattern = class extends Pattern {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "canvas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: document.createElement("canvas")
    });
    Object.defineProperty(this, "context", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.canvas.getContext("2d")
    });
    Object.defineProperty(this, "_clearGrain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  _beforeChanged() {
    this.canvas.width = this.get("width", 200);
    this.canvas.height = this.get("height", 200);
    if (this.isDirty("size") || this.isDirty("density") || this.isDirty("minOpacity") || this.isDirty("maxOpacity") || this.isDirty("colors") || this.isDirty("horizontalGap") || this.isDirty("verticalGap")) {
      this._clearGrain = true;
    }
    super._beforeChanged();
  }
  _changed() {
    super._changed();
    if (this._clearGrain) {
      const width = this.get("width", 200);
      const height = this.get("height", 200);
      const patternData = this.context.getImageData(0, 0, width, height);
      const size = Math.max(1, this.get("size", 1));
      const minOpacity = this.get("minOpacity", 0);
      const maxOpacity = this.get("maxOpacity", 0.3);
      const colors = this.get("colors", [this.get("color", Color.fromHex(0))]);
      const cols = width / size;
      const rows = height / size;
      const density = this.get("density", 1);
      const horizontalGap = this.get("horizontalGap", 0) + 1;
      const verticalGap = this.get("verticalGap", 0) + 1;
      for (let r = 0; r < rows; r++) {
        if (verticalGap > 0) {
          if (r / verticalGap != Math.round(r / verticalGap)) {
            continue;
          }
        }
        for (let c = 0; c < cols; c++) {
          const color2 = colors[Math.floor(Math.random() * colors.length)];
          const alpha = (minOpacity + Math.random() * (maxOpacity - minOpacity)) * 255;
          const rnd = Math.random();
          if (horizontalGap > 0) {
            if (c / horizontalGap != Math.round(c / horizontalGap)) {
              continue;
            }
          }
          if (rnd < density) {
            this._setRectData(c, r, size, width, patternData.data, color2.r, color2.g, color2.b, alpha);
          }
        }
      }
      this.context.putImageData(patternData, 0, 0);
      this._pattern = this.context.createPattern(this.canvas, "repeat");
    }
    this._clearGrain = false;
  }
  _checkDirtyFill() {
    return false;
  }
  _setRectData(col, row, size, width, data, rc, gc, bc, ac) {
    for (var c = col * size; c < col * size + size; c++) {
      for (var r = row * size; r < row * size + size; r++) {
        var i = (r * width + c) * 4;
        data[i] = rc;
        data[i + 1] = gc;
        data[i + 2] = bc;
        data[i + 3] = ac;
      }
    }
  }
};
Object.defineProperty(GrainPattern, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "GrainPattern"
});
Object.defineProperty(GrainPattern, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Pattern.classNames.concat([GrainPattern.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/gradients/RadialGradient.js
var RadialGradient = class extends Gradient {
  /**
   * @ignore
   */
  getFill(target) {
    const bounds = this.getBounds(target);
    let x = 0;
    let y = 0;
    let l = bounds.left || 0;
    let r = bounds.right || 0;
    let t = bounds.top || 0;
    let b = bounds.bottom || 0;
    const width = r - l;
    const height = b - t;
    let radius = target.get("radius");
    if (isNumber(radius)) {
      x = 0;
      y = 0;
    } else {
      radius = Math.min(width, height) / 2;
      x = width / 2;
      y = height / 2;
    }
    let ux = this.get("x");
    let uy = this.get("y");
    if (ux != null) {
      x = relativeToValue(ux, width);
    }
    if (uy != null) {
      y = relativeToValue(uy, height);
    }
    const gradient = this._root._renderer.createRadialGradient(x, y, 0, x, y, radius);
    const stops = this.get("stops");
    if (stops) {
      let i = 0;
      each(stops, (stop) => {
        let offset = stop.offset;
        if (!isNumber(offset)) {
          offset = i / (stops.length - 1);
        }
        let opacity = stop.opacity;
        if (!isNumber(opacity)) {
          opacity = 1;
        }
        let color2 = stop.color;
        if (color2) {
          const lighten = stop.lighten;
          if (lighten) {
            color2 = Color.lighten(color2, lighten);
          }
          const brighten = stop.brighten;
          if (brighten) {
            color2 = Color.brighten(color2, brighten);
          }
          gradient.addColorStop(offset, "rgba(" + color2.r + "," + color2.g + "," + color2.b + "," + opacity + ")");
        }
        i++;
      });
    }
    return gradient;
  }
};
Object.defineProperty(RadialGradient, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "RadialGradient"
});
Object.defineProperty(RadialGradient, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Gradient.classNames.concat([RadialGradient.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/patterns/CirclePattern.js
var CirclePattern = class extends Pattern {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("gap")) {
      this._clear = true;
    }
  }
  _draw() {
    super._draw();
    const checkered = this.get("checkered", false);
    const centered = this.get("centered", true);
    const gap = this.get("gap", 0);
    const rotation = this.get("rotation", 0);
    let w = this.get("width", 100);
    let h = this.get("height", 100);
    let radius = this.get("radius", 3);
    let cellW = radius * 2 + gap;
    let cellH = radius * 2 + gap;
    let cols = Math.round(w / cellW);
    let rows = Math.round(h / cellH);
    cellW = w / cols;
    cellH = h / rows;
    if (rotation != 0) {
      this._display.x = cellW * cos(rotation);
      this._display.y = cellH * sin(rotation);
    }
    const color2 = this.get("color");
    const colorOpacity = this.get("colorOpacity");
    if (color2 || colorOpacity) {
      this._display.beginFill(color2, colorOpacity);
    }
    for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
      for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
        if (!checkered || (r & 1) != 1 && (c & 1) != 1 || (r & 1) == 1 && (c & 1) == 1) {
          let x = c * cellW;
          let y = r * cellH;
          if (centered) {
            x += cellW + gap / 2;
            y += cellH + gap / 2;
          }
          this._display.drawCircle(x - radius, y - radius, radius);
        }
      }
    }
    if (checkered) {
      w = w / 2 - gap * 2;
      h = h / 2 - gap * 2;
    } else {
      w -= gap;
      h -= gap;
    }
    if (color2 || colorOpacity) {
      this._display.endFill();
    }
  }
};
Object.defineProperty(CirclePattern, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "CirclePattern"
});
Object.defineProperty(CirclePattern, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Pattern.classNames.concat([CirclePattern.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/patterns/LinePattern.js
var LinePattern = class extends Pattern {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("gap")) {
      this._clear = true;
    }
  }
  _draw() {
    super._draw();
    const w = this.get("width", 100);
    const h = this.get("height", 100);
    const gap = this.get("gap", 0);
    const strokeWidth = this.get("strokeWidth", 1);
    if (!gap) {
      this._display.moveTo(0, 0);
      this._display.lineTo(w, 0);
    } else {
      let step = gap + strokeWidth;
      let count = h / step;
      for (let i = -count; i < count * 2; i++) {
        const y = Math.round(i * step - step / 2) + 0.5;
        this._display.moveTo(-w, y);
        this._display.lineTo(w * 2, y);
      }
    }
    this._display.lineStyle(strokeWidth, this.get("color"), this.get("colorOpacity"));
    let strokeDasharray = this.get("strokeDasharray");
    if (isNumber(strokeDasharray)) {
      if (strokeDasharray < 0.5) {
        strokeDasharray = [0];
      } else {
        strokeDasharray = [strokeDasharray];
      }
    }
    this._display.setLineDash(strokeDasharray);
    const strokeDashoffset = this.get("strokeDashoffset");
    if (strokeDashoffset) {
      this._display.setLineDashOffset(strokeDashoffset);
    }
    this._display.endStroke();
  }
};
Object.defineProperty(LinePattern, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "LinePattern"
});
Object.defineProperty(LinePattern, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Pattern.classNames.concat([LinePattern.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/patterns/RectanglePattern.js
var RectanglePattern = class extends Pattern {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("gap")) {
      this._clear = true;
    }
  }
  _draw() {
    super._draw();
    const checkered = this.get("checkered", false);
    const centered = this.get("centered", true);
    const gap = this.get("gap", 0);
    const rotation = this.get("rotation", 0);
    let w = this.get("width", 100);
    let h = this.get("height", 100);
    let rectW = this.get("maxWidth", 5);
    let rectH = this.get("maxHeight", 5);
    const display = this._display;
    let cellW = rectW + gap;
    let cellH = rectH + gap;
    let cols = Math.round(w / cellW);
    let rows = Math.round(h / cellH);
    cellW = w / cols;
    cellH = h / rows;
    if (rotation != 0) {
      display.x = cellW / 2 * cos(rotation);
      display.y = -cellH / 2 * sin(rotation);
    }
    for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
      for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
        if (!checkered || (r & 1) != 1 && (c & 1) != 1 || (r & 1) == 1 && (c & 1) == 1) {
          let x = c * cellW;
          let y = r * cellH;
          if (centered) {
            x += (cellW - rectW) / 2;
            y += (cellH - rectH) / 2;
          }
          display.drawRect(x, y, rectW, rectH);
        }
      }
    }
    if (checkered) {
      w = w / 2 - gap * 2;
      h = h / 2 - gap * 2;
    } else {
      w -= gap;
      h -= gap;
    }
    const color2 = this.get("color");
    const colorOpacity = this.get("colorOpacity");
    if (color2 || colorOpacity) {
      display.beginFill(color2, colorOpacity);
      display.endFill();
    }
  }
};
Object.defineProperty(RectanglePattern, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "RectanglePattern"
});
Object.defineProperty(RectanglePattern, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Pattern.classNames.concat([RectanglePattern.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PathPattern.js
var PathPattern = class extends Pattern {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("svgPath")) {
      this._clear = true;
    }
  }
  _draw() {
    super._draw();
    const svgPath = this.get("svgPath");
    if (svgPath != null) {
      this._display.svgPath(svgPath);
    }
    const color2 = this.get("color");
    const colorOpacity = this.get("colorOpacity");
    if (color2 || colorOpacity) {
      this._display.beginFill(color2, colorOpacity);
      this._display.endFill();
    }
  }
};
Object.defineProperty(PathPattern, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "PathPattern"
});
Object.defineProperty(PathPattern, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Pattern.classNames.concat([PathPattern.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/util/DataParser.js
var JSONParser = class {
  /**
   * Parses JSON string.
   *
   * @param   input    JSON
   * @param   options  Options
   * @return           Data
   */
  static parse(input, options) {
    options = this._applyDefaults(options);
    try {
      if (isString(input)) {
        let data = JSON.parse(input);
        if (options.reverse && isArray(data)) {
          data.reverse();
        }
        return data;
      } else if (isArray(input) || isObject(input)) {
        return input;
      } else {
        throw "Unable to parse JSON data";
      }
    } catch (e) {
      return void 0;
    }
  }
  static _applyDefaults(options) {
    const normalized = {};
    const defaults = {
      reverse: false
    };
    if (!options) {
      options = {};
    }
    each2(defaults, (key, val) => {
      normalized[key] = options[key] || val;
    });
    return normalized;
  }
};
var CSVParser = class {
  /**
   * Parses CSV string.
   *
   * @param   input    CSV
   * @param   options  Options
   * @return           Data
   */
  static parse(input, options) {
    options = this._applyDefaults(options);
    let data = this.CSVToArray(input, options.delimiter);
    let res = [], cols = [], col, i;
    for (i = 0; i < options.skipRows; i++) {
      data.shift();
    }
    if (options.useColumnNames) {
      cols = data.shift();
      for (let x = 0; x < cols.length; x++) {
        col = cols[x] != null ? cols[x].replace(/^\s+|\s+$/gm, "") : "";
        if ("" === col) {
          col = "col" + x;
        }
        cols[x] = col;
      }
    }
    let row;
    while (true) {
      row = options.reverse ? data.pop() : data.shift();
      if (!row) {
        break;
      }
      if (options.skipEmpty && row.length === 1 && row[0] === "") {
        continue;
      }
      let dataPoint = {};
      for (i = 0; i < row.length; i++) {
        col = void 0 === cols[i] ? "col" + i : cols[i];
        dataPoint[col] = row[i];
      }
      res.push(dataPoint);
    }
    return res;
  }
  /**
   * @ignore
   */
  static CSVToArray(data, delimiter) {
    delimiter = delimiter || ",";
    let objPattern = new RegExp(
      // Delimiters.
      "(\\" + delimiter + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + delimiter + "\\r\\n]*))",
      "gi"
    );
    let arrData = [
      []
    ];
    let arrMatches = null;
    while (true) {
      arrMatches = objPattern.exec(data);
      if (!arrMatches) {
        break;
      }
      let strMatchedDelimiter = arrMatches[1];
      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {
        arrData.push([]);
      }
      let strMatchedValue;
      if (arrMatches[2]) {
        strMatchedValue = arrMatches[2].replace(new RegExp('""', "g"), '"');
      } else {
        strMatchedValue = arrMatches[3];
      }
      arrData[arrData.length - 1].push(strMatchedValue);
    }
    return arrData;
  }
  static _applyDefaults(options) {
    const normalized = {};
    const defaults = {
      delimiter: ",",
      reverse: false,
      skipRows: 0,
      skipEmpty: true,
      useColumnNames: false
    };
    if (!options) {
      options = {};
    }
    each2(defaults, (key, val) => {
      normalized[key] = options[key] || val;
    });
    return normalized;
  }
};

// node_modules/@amcharts/amcharts5/.internal/core/util/DataProcessor.js
var DataProcessor = class extends Entity {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "_checkDates", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "_checkNumbers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "_checkColors", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "_checkEmpty", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "_checkDeep", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  _afterNew() {
    super._afterNew();
    this._checkFeatures();
    this.on("dateFields", () => this._checkFeatures());
    this.on("dateFormat", () => this._checkFeatures());
    this.on("numericFields", () => this._checkFeatures());
    this.on("colorFields", () => this._checkFeatures());
    this.on("emptyAs", () => this._checkFeatures());
  }
  _checkFeatures() {
    if (this.isDirty("dateFields") || this.isDirty("dateFormat")) {
      this._checkDates = this.get("dateFields") && this.get("dateFields").length > 0;
    }
    if (this.isDirty("numericFields")) {
      this._checkNumbers = this.get("numericFields") && this.get("numericFields").length > 0;
    }
    if (this.isDirty("colorFields")) {
      this._checkColors = this.get("colorFields") && this.get("colorFields").length > 0;
    }
    if (this.isDirty("emptyAs")) {
      this._checkEmpty = this.get("emptyAs") != null;
    }
    this._checkDeepFeatures();
  }
  _checkDeepFeatures() {
    const deepFields = [];
    each(["dateFields", "numericFields", "colorFields"], (where) => {
      each(this.get(where, []), (field) => {
        const steps = field.split(".");
        steps.pop();
        while (steps.length > 0) {
          deepFields.push(steps.join("."));
          steps.pop();
        }
      });
    });
    this._checkDeep = deepFields.length > 0;
    this.setPrivate("deepFields", deepFields);
  }
  /**
   * Processess entire array of data.
   *
   * NOTE: calling this will modify original array!
   */
  processMany(data) {
    if (isArray(data) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty)) {
      each(data, (row) => {
        this.processRow(row);
      });
    }
  }
  /**
   * Processes a row (object) of data.
   *
   * NOTE: calling this will modify values of the original object!
   */
  processRow(row, prefix = "") {
    each2(row, (key, _value) => {
      const lookupKey = prefix + key;
      if (this._checkEmpty) {
        row[key] = this._maybeToEmpty(row[key]);
      }
      if (this._checkNumbers) {
        row[key] = this._maybeToNumber(lookupKey, row[key]);
      }
      if (this._checkDates) {
        row[key] = this._maybeToDate(lookupKey, row[key]);
      }
      if (this._checkColors) {
        row[key] = this._maybeToColor(lookupKey, row[key]);
      }
      if (this._checkDeep && this.getPrivate("deepFields", []).indexOf(lookupKey) !== -1 && isObject(row[key])) {
        this.processRow(row[key], lookupKey + ".");
      }
    });
  }
  _maybeToNumber(field, value) {
    if (this.get("numericFields").indexOf(field) !== -1) {
      return toNumber(value);
    }
    return value;
  }
  _maybeToDate(field, value) {
    if (this.get("dateFields").indexOf(field) !== -1) {
      return this._root.dateFormatter.parse(value, this.get("dateFormat", "")).getTime();
    }
    return value;
  }
  _maybeToEmpty(value) {
    if ((value == null || value == "") && this.get("emptyAs") != null) {
      return this.get("emptyAs");
    }
    return value;
  }
  _maybeToColor(field, value) {
    if (this.get("colorFields").indexOf(field) !== -1) {
      return Color.fromAny(value);
    }
    return value;
  }
};

// node_modules/@amcharts/amcharts5/.internal/core/render/SpriteResizer.js
var SpriteResizer = class extends Container {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "rectangle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this.children.push(Rectangle.new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: color(16777215) }))
    });
    Object.defineProperty(this, "gripL", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this._createGrip("left")
    });
    Object.defineProperty(this, "gripR", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this._createGrip("right")
    });
    Object.defineProperty(this, "gripT", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this._createGrip("top")
    });
    Object.defineProperty(this, "gripB", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: this._createGrip("bottom")
    });
    Object.defineProperty(this, "_is", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 1
    });
    Object.defineProperty(this, "_ix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "_iw", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "_positionDP", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_isHover", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  _afterNew() {
    super._afterNew();
    this.addTag("resizer");
    this.set("visible", false);
    this.gripL.events.on("dragged", (e) => {
      this._resize(e.target, -1);
    });
    this.gripR.events.on("dragged", (e) => {
      this._resize(e.target, 1);
    });
    this.gripL.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
    this.gripR.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
    this.gripT.events.on("dragged", (e) => {
      this._rotate(e, 90);
    });
    this.gripB.events.on("dragged", (e) => {
      this._rotate(e, -90);
    });
    this.gripT.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
    this.gripB.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
  }
  _resizeStart(grip) {
    const sprite = this.get("sprite");
    if (sprite) {
      this._is = sprite.get("scale", 1);
      this._ix = grip.x();
      this._iw = this.width() / 2;
    }
  }
  _resize(grip, c) {
    const sprite = this.get("sprite");
    const spriteTemplate = this.get("spriteTemplate");
    if (sprite) {
      const scale = Math.max(0.01, this._is * (1 + c * (grip.x() - this._ix) / this._iw));
      if (spriteTemplate) {
        spriteTemplate.set("scale", scale);
      } else {
        sprite.set("scale", scale);
      }
      sprite.states.lookup("default").set("scale", scale);
      this._updatePositions();
    }
  }
  _rotate(e, delta) {
    const sprite = this.get("sprite");
    const spriteTemplate = this.get("spriteTemplate");
    if (sprite) {
      const parent = this.parent;
      if (parent) {
        const rotationStep = this.get("rotationStep", 10);
        let angle = Math.round((getAngle({ x: this.x(), y: this.y() }, parent.toLocal(e.point)) + delta) / rotationStep) * rotationStep;
        if (spriteTemplate) {
          spriteTemplate.set("rotation", angle);
        } else {
          sprite.set("rotation", angle);
        }
        sprite.states.lookup("default").set("rotation", angle);
        this._updatePositions();
      }
    }
  }
  _createGrip(themeTag) {
    const container = this.children.push(Container.new(this._root, {
      themeTags: ["grip", themeTag],
      setStateOnChildren: true,
      draggable: true
    }));
    container.children.push(RoundedRectangle.new(this._root, {
      themeTags: ["outline"],
      centerX: p50,
      centerY: p50
    }));
    container.children.push(RoundedRectangle.new(this._root, {
      centerX: p50,
      centerY: p50
    }));
    return container;
  }
  _updateChildren() {
    super._updateChildren();
    if (this.isDirty("sprite")) {
      const sprite = this.get("sprite");
      if (sprite) {
        this.show(0);
        this.setPrivate("visible", true);
        this._updatePositions();
        const parent = sprite.parent;
        if (parent) {
          parent.children.moveValue(this, 0);
        }
        this._positionDP = sprite.events.on("positionchanged", () => {
          this._updatePositions();
        });
      } else {
        this.hide(0);
        this.setPrivate("visible", false);
        if (this._positionDP) {
          this._positionDP.dispose();
        }
      }
    }
    if (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) {
      this._updatePositions();
    }
  }
  _updatePositions() {
    const sprite = this.get("sprite");
    if (sprite) {
      let bounds = sprite.localBounds();
      let scale = sprite.get("scale", 1);
      let d = 20;
      let w = (bounds.right - bounds.left) * scale + d;
      let h = (bounds.bottom - bounds.top) * scale + d;
      let a = sprite.get("rotation", 0);
      const rectangle = this.rectangle;
      let cx = sprite.get("centerX", p50);
      let cy = sprite.get("centerY", p50);
      let cxr = 0;
      if (cx instanceof Percent) {
        cxr = cx.value;
      }
      let cyr = 0;
      if (cy instanceof Percent) {
        cyr = cy.value;
      }
      rectangle.setAll({ centerX: cx, centerY: cy, width: w, height: h });
      this.setAll({ x: sprite.x() + d * (cxr - 0.5) * cos(a) - d * (cyr - 0.5) * sin(a), y: sprite.y() + d * (cyr - 0.5) * cos(a) + d * (cxr - 0.5) * sin(a), width: w, height: h, rotation: a });
      this.gripT.setAll({ x: (0.5 - cxr) * w, y: -cyr * h });
      this.gripB.setAll({ x: (0.5 - cxr) * w, y: (1 - cyr) * h });
      this.gripL.setAll({ x: -cxr * w, y: (0.5 - cyr) * h });
      this.gripR.setAll({ x: (1 - cxr) * w, y: (0.5 - cyr) * h });
      this.rectangle.setAll({ width: w, height: h });
    }
  }
};
Object.defineProperty(SpriteResizer, "className", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "SpriteResizer"
});
Object.defineProperty(SpriteResizer, "classNames", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Container.classNames.concat([SpriteResizer.className])
});

// node_modules/@amcharts/amcharts5/.internal/core/util/Net.js
var Net_exports = {};
__export(Net_exports, {
  load: () => load,
  readBlob: () => readBlob
});
function load(url, target, options) {
  return new Promise((success, error) => {
    let isBlob = options != null && options.responseType == "blob";
    let xhr = new XMLHttpRequest();
    xhr.onload = () => {
      if (xhr.status === 200) {
        let response;
        let blob;
        if (isBlob) {
          blob = xhr.response;
          readBlob(blob).then((response2) => {
            let output2 = {
              xhr,
              error: false,
              response: response2,
              blob,
              type: xhr.getResponseHeader("Content-Type"),
              target
            };
            success(output2);
          });
          return;
        } else {
          response = xhr.responseText || xhr.response;
        }
        let output = {
          xhr,
          error: false,
          response,
          blob,
          type: xhr.getResponseHeader("Content-Type"),
          target
        };
        success(output);
      } else {
        error({
          xhr,
          error: true,
          type: xhr.getResponseHeader("Content-Type"),
          target
        });
      }
    };
    xhr.onerror = () => {
      error({
        xhr,
        error: true,
        type: xhr.getResponseHeader("Content-Type"),
        target
      });
    };
    xhr.open("GET", url, true);
    if (options && options.withCredentials) {
      xhr.withCredentials = true;
    }
    if (options != null) {
      if (options.requestHeaders != null) {
        for (let i = 0; i < options.requestHeaders.length; i++) {
          let header = options.requestHeaders[i];
          xhr.setRequestHeader(header.key, header.value);
        }
      }
      if (options.responseType != null) {
        xhr.responseType = options.responseType;
      }
    }
    xhr.send();
  });
}
function readBlob(blob) {
  return new Promise((success, error) => {
    const reader = new FileReader();
    reader.onload = (_event) => {
      success(reader.result);
    };
    reader.onerror = (e) => {
      error(e);
    };
    reader.readAsText(blob);
  });
}
export {
  ArrayDisposer,
  BlendMode,
  Bullet,
  Button,
  CSVParser,
  Chart,
  Circle,
  CirclePattern,
  Color,
  ColorSet,
  Component,
  Container,
  CounterDisposer,
  DataItem,
  DataProcessor,
  DateFormatter,
  Disposer,
  DurationFormatter,
  Ellipse,
  Entity,
  Gradient,
  GrainPattern,
  Graphics,
  GridLayout,
  HeatLegend,
  HorizontalLayout,
  InterfaceColors,
  JSONParser,
  JsonData,
  Label,
  Layout,
  Legend,
  Line,
  LinePattern,
  LinearGradient,
  ListData,
  Modal,
  MultiDisposer,
  MutableValueDisposer,
  NumberFormatter,
  PathPattern,
  Pattern,
  Percent,
  Picture,
  PicturePattern,
  PointedRectangle,
  Polygon,
  RadialGradient,
  RadialLabel,
  RadialText,
  Rectangle,
  RectanglePattern,
  Root,
  RoundedRectangle,
  Scrollbar,
  SerialChart,
  Series,
  Slice,
  Slider,
  Sprite,
  SpriteResizer,
  Star,
  Template,
  Text,
  TextFormatter,
  Theme,
  Tick,
  Timezone,
  Tooltip,
  Triangle,
  VerticalLayout,
  addLicense,
  Array_exports as array,
  color,
  disposeAllRootElements,
  Ease_exports as ease,
  Math_exports as math,
  Net_exports as net,
  Object_exports as object,
  p0,
  p100,
  p50,
  percent,
  ready,
  registry,
  Time_exports as time,
  Type_exports as type,
  Utils_exports as utils
};
//# sourceMappingURL=@amcharts_amcharts5.js.map
