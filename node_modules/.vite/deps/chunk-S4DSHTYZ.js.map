{
  "version": 3,
  "sources": ["../../src/.internal/core/render/Button.ts", "../../src/.internal/core/util/Draw.ts", "../../src/.internal/core/render/Line.ts", "../../src/.internal/core/render/Chart.ts", "../../src/.internal/core/render/SerialChart.ts", "../../src/.internal/core/render/Tick.ts"],
  "sourcesContent": ["import type { Label } from \"../render/Label\";\nimport type { Graphics } from \"../render/Graphics\";\n\nimport { RoundedRectangle } from \"../render/RoundedRectangle\";\nimport { Container, IContainerPrivate, IContainerSettings } from \"./Container\";\n\nimport * as $utils from \"../../core/util/Utils\";\n\nexport interface IButtonSettings extends IContainerSettings {\n\n\t/**\n\t * A [[Label]] element for the button to show as a label.\n\t */\n\tlabel?: Label;\n\n\t/**\n\t * A [[Graphics]] element for the button to show as icon.\n\t */\n\ticon?: Graphics;\n\n}\n\nexport interface IButtonPrivate extends IContainerPrivate {\n}\n\n/**\n * Draws an interactive button.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info\n * @important\n */\nexport class Button extends Container {\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"button\"]);\n\n\t\tsuper._afterNew();\n\n\t\tif (!this._settings.background) {\n\t\t\tthis.set(\"background\", RoundedRectangle.new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(this._settings.themeTags, [\"background\"])\n\t\t\t}));\n\t\t}\n\n\t\tthis.setPrivate(\"trustBounds\", true);\n\t}\n\n\tdeclare public _settings: IButtonSettings;\n\tdeclare public _privateSettings: IButtonPrivate;\n\n\tpublic static className: string = \"Button\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Button.className]);\n\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tif (this.isDirty(\"icon\")) {\n\t\t\tconst previous = this._prevSettings.icon;\n\t\t\tconst icon = this.get(\"icon\")!;\n\t\t\tif (icon !== previous) {\n\t\t\t\tthis._disposeProperty(\"icon\");\n\n\t\t\t\tif (previous) {\n\t\t\t\t\tprevious.dispose();\n\t\t\t\t}\n\t\t\t\tif (icon) {\n\t\t\t\t\tthis.children.push(icon);\n\t\t\t\t}\n\n\t\t\t\tthis._prevSettings.icon = icon;\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"label\")) {\n\t\t\tconst previous = this._prevSettings.label;\n\t\t\tconst label = this.get(\"label\")!;\n\t\t\tif (label !== previous) {\n\t\t\t\tthis._disposeProperty(\"label\");\n\t\t\t\tif (previous) {\n\t\t\t\t\tprevious.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (label) {\n\t\t\t\t\tthis.children.push(label);\n\t\t\t\t}\n\n\t\t\t\tthis._prevSettings.label = label;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/** @ignore *//** */\n\nimport type { IPoint } from \"./IPoint\"\nimport * as $math from \"./Math\";\nimport type { IGraphics } from \"../render/backend/Renderer\";\n\n/**\n * @ignore\n */\nexport function segmentedLine(display: IGraphics, segments: Array<Array<Array<IPoint>>>) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tline(display, groups[g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function line(display: IGraphics, points: Array<IPoint>) {\n\tfor (let p = 0, len = points.length; p < len; p++) {\n\t\tconst point = points[p];\n\t\tdisplay.lineTo(point.x, point.y);\n\t}\n}\n\n/**\n * @ignore\n */\nexport function moveTo(display: IGraphics, point: IPoint) {\n\tdisplay.moveTo(point.x, point.y);\n}\n\n/**\n * @ignore\n */\nexport function clear(display: IGraphics) {\n\tdisplay.clear();\n}\n\n/**\n * @ignore\n */\nexport function smoothedSegmentedline(display: IGraphics, segments: Array<Array<Array<IPoint>>>, tensionX: number, tensionY: number) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tconst points = groups[g];\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\tdisplay.lineTo(points[0].x, points[0].y)\n\t\t\t\t\t}\n\t\t\t\t\tsmoothedLine(display, points, tensionX, tensionY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function smoothedLine(display: IGraphics, points: Array<IPoint>, tensionX: number, tensionY: number) {\n\n\tfor (let i = points.length - 1; i > 0; i--) {\n\t\tlet p0 = points[i];\n\t\tlet p1 = points[i - 1];\n\n\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\tpoints.splice(i - 1, 1);\n\t\t}\n\t}\n\n\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\tline(display, points);\n\t\treturn;\n\t}\n\n\ttensionX = 1 - tensionX + 0.00001;\n\ttensionY = 1 - tensionY + 0.00001;\n\n\tlet first = points[0];\n\tlet last = points[points.length - 1];\n\n\tlet closed: boolean = false;\n\n\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\tclosed = true;\n\t}\n\n\t// Can't moveTo here, as it wont be possible to have fill then.\n\tlet path: string = \"\";\n\n\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\tlet p0: IPoint = points[i - 1];\n\n\t\tlet p1: IPoint = points[i];\n\n\t\tlet p2: IPoint = points[i + 1];\n\n\t\tlet p3: IPoint = points[i + 2];\n\n\t\tif (i === 0) {\n\t\t\tif (closed) {\n\t\t\t\tp0 = points[len - 2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp0 = points[0];\n\t\t\t}\n\t\t} else if (i == len - 1) {\n\t\t\tif (closed) {\n\t\t\t\tp3 = points[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp3 = p2;\n\t\t\t}\n\t\t}\n\n\n\t\tlet controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n\t\tlet controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n\n\t\tdisplay.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n\t}\n\n\treturn path;\n}\n", "import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\nimport type { IPoint } from \"../util/IPoint\";\nimport * as $draw from \"../util/Draw\";\n\nexport interface ILineSettings extends IGraphicsSettings {\n\n\t/**\n\t * A list of [[IPoint]] (x/y coordinates) points for the line.\n\t */\n\tpoints?: Array<IPoint>;\n\n\t/**\n\t * A list of [[IPoint]] arrays for different segments of the line.\n\t * \n\t * @since 5.1.4\n\t */\n\tsegments?: Array<Array<Array<IPoint>>>;\n}\n\nexport interface ILinePrivate extends IGraphicsPrivate {\n}\n\n/**\n * Draws a line.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n * @important\n */\nexport class Line extends Graphics {\n\n\tdeclare public _settings: ILineSettings;\n\tdeclare public _privateSettings: ILinePrivate;\n\n\tpublic static className: string = \"Line\";\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([Line.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"points\") || this.isDirty(\"segments\") || this._sizeDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\n\t\t\tconst points = this.get(\"points\");\n\t\t\tconst segments = this.get(\"segments\");\n\n\t\t\tif (points && points.length > 0) {\n\t\t\t\tlet point = points[0];\n\n\t\t\t\tthis._display.moveTo(point.x, point.y);\n\t\t\t\t$draw.segmentedLine(this._display, [[points]]);\n\t\t\t}\n\t\t\telse if (segments) {\n\t\t\t\t$draw.segmentedLine(this._display, segments);\n\t\t\t}\n\t\t\telse if (!this.get(\"draw\")) {\n\t\t\t\tlet w = this.width();\n\t\t\t\tlet h = this.height();\n\n\t\t\t\tthis._display.moveTo(0, 0);\n\t\t\t\tthis._display.lineTo(w, h);\n\t\t\t}\n\t\t}\n\t}\n}\n", "import { Container, IContainerSettings, IContainerPrivate, IContainerEvents } from \"../../core/render/Container\";\nimport { p100 } from \"../../core/util/Percent\";\n\nexport interface IChartSettings extends IContainerSettings {\n}\n\nexport interface IChartPrivate extends IContainerPrivate {\n}\n\nexport interface IChartEvents extends IContainerEvents {\n}\n\n/**\n * A base class for all charts.\n */\nexport abstract class Chart extends Container {\n\tpublic static className: string = \"Chart\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Chart.className]);\n\n\tdeclare public _settings: IChartSettings;\n\tdeclare public _privateSettings: IChartPrivate;\n\tdeclare public _events: IChartEvents;\n\n\t/**\n\t * A [[Container]] chart places its elements in.\n\t * \n\t * @default Container.new()\n\t */\n\tpublic readonly chartContainer: Container = this.children.push(Container.new(this._root, { width: p100, height: p100, interactiveChildren: false }));\n\n\t/**\n\t * A [[Container]] chart places its bullets in.\n\t * \n\t * @default Container.new()\n\t */\n\tpublic readonly bulletsContainer: Container = Container.new(this._root, { interactiveChildren: false, isMeasured: false, position: \"absolute\", width: p100, height: p100 });\n\n}", "import type { Series } from \"./Series\";\n\nimport { Chart, IChartSettings, IChartPrivate, IChartEvents } from \"./Chart\";\nimport { Container } from \"../../core/render/Container\";\nimport { ListAutoDispose } from \"../../core/util/List\";\nimport { p100 } from \"../../core/util/Percent\";\nimport * as $array from \"../../core/util/Array\";\nimport type { ColorSet } from \"../../core/util/ColorSet\";\n\nexport interface ISerialChartSettings extends IChartSettings {\n\t/**\n\t * A [[ColorSet]] to use when asigning colors for series.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/#Series_colors} for more info\n\t */\n\tcolors?: ColorSet;\n}\n\nexport interface ISerialChartPrivate extends IChartPrivate {\n}\n\nexport interface ISerialChartEvents extends IChartEvents {\n}\n\n/**\n * A base class for all series-based charts.\n */\nexport abstract class SerialChart extends Chart {\n\tpublic static className: string = \"SerialChart\";\n\tpublic static classNames: Array<string> = Chart.classNames.concat([SerialChart.className]);\n\n\tdeclare public _settings: ISerialChartSettings;\n\tdeclare public _privateSettings: ISerialChartPrivate;\n\tdeclare public _seriesType: Series;\n\tdeclare public _events: ISerialChartEvents;\n\n\t/**\n\t * A [[Container]] where chart will store all series.\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly seriesContainer: Container = Container.new(this._root, { width: p100, height: p100, isMeasured: false });\n\n\t/**\n\t * A list of chart's series.\n\t */\n\tpublic readonly series: ListAutoDispose<this[\"_seriesType\"]> = new ListAutoDispose();\n\n\tprotected _afterNew() {\n\t\tsuper._afterNew();\n\n\t\tthis._disposers.push(this.series);\n\n\t\tconst children = this.seriesContainer.children;\n\n\t\tthis._disposers.push(this.series.events.onAll((change) => {\n\t\t\tif (change.type === \"clear\") {\n\t\t\t\t$array.each(change.oldValues, (series) => {\n\t\t\t\t\tthis._removeSeries(series);\n\t\t\t\t})\n\t\t\t\tconst colors = this.get(\"colors\");\n\t\t\t\tif (colors) {\n\t\t\t\t\tcolors.reset();\n\t\t\t\t}\n\n\t\t\t} else if (change.type === \"push\") {\n\t\t\t\tchildren.moveValue(change.newValue);\n\t\t\t\tthis._processSeries(change.newValue);\n\t\t\t} else if (change.type === \"setIndex\") {\n\t\t\t\tchildren.setIndex(change.index, change.newValue);\n\t\t\t\tthis._processSeries(change.newValue);\n\t\t\t} else if (change.type === \"insertIndex\") {\n\t\t\t\tchildren.insertIndex(change.index, change.newValue);\n\t\t\t\tthis._processSeries(change.newValue);\n\t\t\t} else if (change.type === \"removeIndex\") {\n\t\t\t\tthis._removeSeries(change.oldValue);\n\t\t\t} else if (change.type === \"moveIndex\") {\n\t\t\t\tchildren.moveValue(change.value, change.newIndex);\n\t\t\t\tthis._processSeries(change.value);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unknown IListEvent type\");\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected _processSeries(series: this[\"_seriesType\"]) {\n\t\tseries.chart = this;\n\t\tseries._placeBulletsContainer(this);\n\t}\n\n\tprotected _removeSeries(series: this[\"_seriesType\"]) {\n\t\tif (!series.isDisposed()) {\n\t\t\tthis.seriesContainer.children.removeValue(series);\n\t\t\tseries._removeBulletsContainer();\n\t\t}\n\t}\n}\n", "import { Line, ILineSettings, ILinePrivate } from \"./Line\";\n\n\nexport interface ITickSettings extends ILineSettings {\n\n\t/**\n\t * Length in pixels.\n\t */\n\tlength?: number;\n\n\t/**\n\t * Location within target space. 0 - beginning, 1 - end.\n\t */\n\tlocation?: number;\n\n}\n\nexport interface ITickPrivate extends ILinePrivate {\n}\n\n/**\n * Draws a tick element (mostly used on axes).\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n */\nexport class Tick extends Line {\n\n\tdeclare public _settings: ITickSettings;\n\tdeclare public _privateSettings: ITickPrivate;\n\n\tpublic static className: string = \"Tick\";\n\tpublic static classNames: Array<string> = Line.classNames.concat([Tick.className]);\n}\n"],
  "mappings": "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",
  "names": ["len"]
}
